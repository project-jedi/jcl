(*$JPPDEFINEMACRO JCLSORTEDMAPINT(ENTRYTYPENAME, ENTRYARRAYTYPENAME,
  SELFCLASSNAME, ANCESTORNAME, STDMAPINTERFACENAME, SORTEDMAPINTERFACENAME, ITRINTERFACENAME, KEYSETINTERFACENAME, VALUECOLLECTIONINTERFACENAME,
  INTERFACEADDITIONAL, SECTIONADDITIONAL, KEYOWNERSHIPDECLARATION, VALUEOWNERSHIPDECLARATION,
  KEYCONSTKEYWORD, KEYTYPENAME, VALUECONSTKEYWORD, VALUETYPENAME)
SELFCLASSNAME = class(ANCESTORNAME, {$IFDEF THREADSAFE} IJclLockable, {$ENDIF THREADSAFE}
  IJclIntfCloneable, IJclCloneable, IJclGrowable, IJclPackable, IJclBaseContainer,INTERFACEADDITIONAL
  STDMAPINTERFACENAME, SORTEDMAPINTERFACENAME)SECTIONADDITIONAL
private
  FEntries: ENTRYARRAYTYPENAME;
  function BinarySearch(KEYCONSTKEYWORDKey: KEYTYPENAME): Integer;
protected
  procedure AssignDataTo(Dest: TJclAbstractContainerBase); override;
  {$JPPUNDEF GENERIC}{$IFDEF KEYGENERIC}{$JPPDEFINE GENERIC}{$ENDIF}{$IFDEF VALUEGENERIC}{$JPPDEFINE GENERIC}{$ENDIF}{$JPPUNDEF REFCOUNTED}{$IFDEF KEYREFCOUNTED}{$JPPDEFINE REFCOUNTED}{$ENDIF}{$IFDEF VALUEREFCOUNTED}{$JPPDEFINE REFCOUNTED}{$ENDIF}{$JPPUNDEF ZEROINIT}{$IFDEF KEYZEROINIT}{$JPPDEFINE ZEROINIT}{$ENDIF}{$IFDEF VALUEZEROINIT}{$JPPDEFINE ZEROINIT}{$ENDIF}{$JPPEXPANDMACRO MOVEARRAYINT(MoveArray,ENTRYARRAYTYPENAME,)}
public
  constructor Create(ACapacity: IntegerVALUEOWNERSHIPDECLARATIONKEYOWNERSHIPDECLARATION);
  destructor Destroy; override;
  { IJclPackable }
  procedure SetCapacity(Value: Integer); override;
  { STDMAPINTERFACENAME }
  procedure Clear;
  function ContainsKey(KEYCONSTKEYWORDKey: KEYTYPENAME): Boolean;
  function ContainsValue(VALUECONSTKEYWORDValue: VALUETYPENAME): Boolean;
  function Extract(KEYCONSTKEYWORDKey: KEYTYPENAME): VALUETYPENAME;
  function GetValue(KEYCONSTKEYWORDKey: KEYTYPENAME): VALUETYPENAME;
  function IsEmpty: Boolean;
  function KeyOfValue(VALUECONSTKEYWORDValue: VALUETYPENAME): KEYTYPENAME;
  function KeySet: KEYSETINTERFACENAME;
  function MapEquals(const AMap: STDMAPINTERFACENAME): Boolean;
  procedure PutAll(const AMap: STDMAPINTERFACENAME);
  procedure PutValue(KEYCONSTKEYWORDKey: KEYTYPENAME; VALUECONSTKEYWORDValue: VALUETYPENAME);
  function Remove(KEYCONSTKEYWORDKey: KEYTYPENAME): VALUETYPENAME;
  function Size: Integer;
  function Values: VALUECOLLECTIONINTERFACENAME;
  { SORTEDMAPINTERFACENAME }
  function FirstKey: KEYTYPENAME;
  function HeadMap(KEYCONSTKEYWORDToKey: KEYTYPENAME): SORTEDMAPINTERFACENAME;
  function LastKey: KEYTYPENAME;
  function SubMap(KEYCONSTKEYWORDFromKey, ToKey: KEYTYPENAME): SORTEDMAPINTERFACENAME;
  function TailMap(KEYCONSTKEYWORDFromKey: KEYTYPENAME): SORTEDMAPINTERFACENAME;
  {$IFDEF SUPPORTS_FOR_IN}
  function GetEnumerator: ITRINTERFACENAME;
  {$ENDIF SUPPORTS_FOR_IN}
end;*)
(*$JPPDEFINEMACRO JCLSORTEDMAPITRINT(SELFCLASSNAME, ITRINTERFACENAME, MAPCLASSNAME, TYPENAME)
SELFCLASSNAME = class(TJclAbstractIterator, ITRINTERFACENAME, {$IFDEF THREADSAFE} IJclLockable, {$ENDIF THREADSAFE}
  IJclIntfCloneable, IJclCloneable)
private
  FCursor: Integer;
  FStart: TItrStart;
  FOwnMap: MAPCLASSNAME;
protected
  procedure AssignPropertiesTo(Dest: TJclAbstractIterator); override;
  function CreateEmptyIterator: TJclAbstractIterator; override;
public
  constructor Create(AOwnMap: MAPCLASSNAME; ACursor: Integer; AValid: Boolean; AStart: TItrStart);
  { ITRINTERFACENAME }
  function Add(const AEntry: TYPENAME): Boolean;
  procedure Extract;
  function GetEntry: TYPENAME;
  function HasNext: Boolean;
  function HasPrevious: Boolean;
  function Insert(const AEntry: TYPENAME): Boolean;
  function IteratorEquals(const AIterator: ITRINTERFACENAME): Boolean;
  function Next: TYPENAME;
  function NextIndex: Integer;
  function Previous: TYPENAME;
  function PreviousIndex: Integer;
  procedure Remove;
  procedure Reset;
  procedure SetEntry(const AEntry: TYPENAME);
  {$IFDEF SUPPORTS_FOR_IN}
  function MoveNext: Boolean;
  property Current: TYPENAME read GetEntry;
  {$ENDIF SUPPORTS_FOR_IN}
end;*)
