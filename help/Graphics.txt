<DECL>--------------------------------------------------------------------------
[Declaration]
function BrightColorChannel(Channel: Byte; Pct: Extended): Byte;
[ShortDescr]
Brightens one channel of a color by a percentage.
[Description]
BrightColorChannel brightens one channel of a color by a certain percentage.
[Parameters]
Count=2
1=Channel:Byte=Value of the color channel to brighten.
2=Pct:Extended=The percentage with which to brighten the channel. Percentage should
be between 0 and 1.0.
[Result]
The brightened channel.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=BrightColor
2=DarkColor
3=DarkColorChannel
<DECL>--------------------------------------------------------------------------
[Declaration]
function DarkColorChannel(Channel: Byte; Pct: Extended): Byte;
[ShortDescr]
Darkens one channel of a color by a percentage.
[Description]
DarkColorChannel darkens one channel of a color by a certain percentage.
[Parameters]
Count=2
1=Channel:Byte=Value of the color channel to darken.
2=Pct:Extended=The percentage with which to darken the channel. Percentage should
be between 0 and 1.0.
[Result]
The darkened channel.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=BrightColor
2=DarkColor
3=BrightColorChannel
<DECL>--------------------------------------------------------------------------
[Declaration]
function DarkColor(Color: TColor; Pct: Extended): TColor;
[ShortDescr]
Darkens a color by a percentage.
[Description]
DarkColor darkens a color by a certain percentage.
[Parameters]
Count=2
1=Color:TColor=The color to darken.
2=Pct:Extended=The percentage with which to darken the color. Percentage should
be between 0 and 1.0.
[Result]
The darkened color.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=BrightColor
2=BrightColorChannel
3=DarkColorChannel
<DECL>--------------------------------------------------------------------------
[Declaration]
function BrightColor(Color: TColor; Pct: Extended): TColor;
[ShortDescr]
Brightens a color by a percentage.
[Description]
BrightColor brightens a color by a certain percentage.
[Parameters]
Count=2
1=Color:TColor=The color to brighten.
2=Pct:Extended=The percentage with which to brighten the color. Percentage should
be between 0 and 1.0.
[Result]
The brightened color.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=BrightColorChannel
2=DarkColor
3=DarkColorChannel
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure GetRGBValue(const Color: TColor; out Red, Green, Blue: Byte);
[ShortDescr]
Returns the Red, Green and Blue components of a TColor.
[Description]
GetRGBValue returns the intensity of the Red, Green and Blue components of the
supplied TColor. You can use the <REF>GetColorFlag</REF> to extract the remaining
Flag component.
[Parameters]
Count=4
1=Color:TColor=The color from which you want to extract the individual components.
2=Red:Byte=The intensity of the Red component.
3=Green:Byte=The intensity of the Green component.
4=Blue:Byte=The intensity of the Blue component.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=2
1=SetRGBValue
2=GetColorFlag
<DECL>--------------------------------------------------------------------------
[Declaration]
function SetRGBValue(Red, Green, Blue: Byte): TColor;
[ShortDescr]
Returns a TColor initialized with the supplied values.
[Description]
SetRGBValue returns a TColor value with the individual color components
initialized to the supplied intensities. The Flag component (high order byte) is
initialized to 0.
[Parameters]
Count=3
1=Red:Byte=Intensity for the Red component of the returned TColor value.
2=Green:Byte=Intensity for the Green component of the returned TColor value.
3=Blue:Byte=Intensity for the Blue component of the returned TColor value.
[Result]
The TColor value initialized with the supplied values.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=GetRGBValue
<DECL>--------------------------------------------------------------------------
[Declaration]
function SetColorRed(const Color: TColor; Red: Byte): TColor;
[ShortDescr]
Sets the Red component of a TColor.
[Description]
SetColorRed sets intensity of the Red component of a TColor.
[Parameters]
Count=2
1=Color:TColor=The color whose Red component to set.
2=Red:Byte=New intensity for the Red component.
[Result]
Copy of the supplied color after the Red component has been modified.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=SetRGBValue
2=SetColorGreen
3=SetColorBlue
4=SetColorFlag
<DECL>--------------------------------------------------------------------------
[Declaration]
function SetColorGreen(const Color: TColor; Green: Byte): TColor;
[ShortDescr]
Sets the Green component of a TColor.
[Description]
SetColorGreen sets intensity of the Green component of a TColor.
[Parameters]
Count=2
1=Color:TColor=The color whose Green component to set.
2=Green:Byte=New intensity for the Green component.
[Result]
Copy of the supplied color after the Green component has been modified.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=SetRGBValue
2=SetColorRed
3=SetColorBlue
4=SetColorFlag
<DECL>--------------------------------------------------------------------------
[Declaration]
function SetColorBlue(const Color: TColor; Blue: Byte): TColor;
[ShortDescr]
Sets the Blue component of a TColor.
[Description]
SetColorBlue sets intensity of the Blue component of a TColor.
[Parameters]
Count=2
1=Color:TColor=The color whose Blue component to set.
2=Blue:Byte=New intensity for the Blue component.
[Result]
Copy of the supplied color after the Blue component has been modified.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=SetRGBValue
2=SetColorRed
3=SetColorGreen
4=SetColorFlag
<DECL>--------------------------------------------------------------------------
[Declaration]
function SetColorFlag(const Color: TColor; Flag: Byte): TColor;
[ShortDescr]
Sets the Flag component of a TColor.
[Description]
SetColorFlag sets the Flag component of a TColor. The Flag component
is contained in the high order byte of the TColor value and determines how
Delphi displays the color. Currently this can be either 0, 1, or 2 and have the
following meaning:
  <TABLE>
    <TR VALIGN="top">
    <TH align=left width=25%>Value</TH><TH align=left width=75%>Description</TH></TR>
    <TR VALIGN="top"><TD width=25%>0</TD>
    <TD width=75%>The color obtained is the closest matching color in the system palette.</TD>
    </TR>
    <TR VALIGN="top"><TD width=25%>1</TD>
    <TD width=75%>The color obtained is the closest matching color in the currently realized palette.</TD>
    </TR>
    <TR VALIGN="top"><TD width=25%>2</TD>
    <TD width=75%>The value is matched with the nearest color in the logical palette of the current device context.</TD>
    </TR>
  </TABLE>
[Parameters]
Count=2
1=Color:TColor=The color whose Flag component to set.
2=Flag:Byte=Value for the Flag component. Valid values are 0,1 and 2. See the description above.
[Result]
Copy of the supplied color after the Flag component has been modified.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=SetRGBValue
2=SetColorRed
3=SetColorGreen
4=SetColorBlue
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetColorRed(const Color: TColor): Byte;
[ShortDescr]
Extracts the Red component from a TColor.
[Description]
GetColorRed extracts the Red component from a TColor value.
[Parameters]
Count=1
1=Color:TColor=The Color value from which to extract the Red component.
[Result]
The Red component from the supplied TColor. The value ranges from 0 to 255.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=GetRGBValue
2=GetColorBlue(Color: TColor): Byte;
3=GetColorGreen(Color: TColor): Byte;
4=GetColorFlag(Color: TColor): Byte;
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetColorBlue(const Color: TColor): Byte;
[ShortDescr]
Extracts the Blue component from a TColor.
[Description]
GetColorBlue extracts the Blue component from a TColor value.
[Parameters]
Count=1
1=Color:TColor=The Color value from which to extract the Blue component.
[Result]
The Blue component from the supplied TColor. The value ranges from 0 to 255.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=GetRGBValue
2=GetColorRed(Color: TColor): Byte;
3=GetColorGreen(Color: TColor): Byte;
4=GetColorFlag(Color: TColor): Byte;
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetColorGreen(const Color: TColor): Byte;
[ShortDescr]
Extracts the Green component from a TColor.
[Description]
GetColorGreen extracts the Green component from a TColor value.
[Parameters]
Count=1
1=Color:TColor=The Color value from which to extract the Green component.
[Result]
The Green component from the supplied TColor. The value ranges from 0 to 255.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=GetRGBValue
2=GetColorRed(Color: TColor): Byte;
3=GetColorBlue(Color: TColor): Byte;
4=GetColorFlag(Color: TColor): Byte;
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetColorFlag(const Color: TColor): Byte;
[ShortDescr]
Extracts the Flag component from a TColor.
[Description]
GetColorFlag extracts the Flag component from a TColor value. The Flag component
is contained in the high order byte of the TColor value and determines how
Delphi displays the color. Currently this can be either 0, 1, or 2 and have the
following meaning:
  <TABLE>
    <TR VALIGN="top">
    <TH align=left width=25%>Value</TH><TH align=left width=75%>Description</TH></TR>
    <TR VALIGN="top"><TD width=25%>0</TD>
    <TD width=75%>The color obtained is the closest matching color in the system palette.</TD>
    </TR>
    <TR VALIGN="top"><TD width=25%>1</TD>
    <TD width=75%>The color obtained is the closest matching color in the currently realized palette.</TD>
    </TR>
    <TR VALIGN="top"><TD width=25%>2</TD>
    <TD width=75%>The value is matched with the nearest color in the logical palette of the current device context.</TD>
    </TR>
  </TABLE>
[Parameters]
Count=1
1=Color:TColor=The Color value from which to extract the Flag component.
[Result]
The Flag component from the supplied TColor. The value ranges from 0 to 2.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=4
1=GetRGBValue
2=GetColorRed(Color: TColor): Byte;
3=GetColorBlue(Color: TColor): Byte;
4=GetColorGreen(Color: TColor): Byte;
<DECL>--------------------------------------------------------------------------
[Declaration]
function PointAssign(X, Y: Integer): TPoint;
[ShortDescr]
Initializes a TPoint with the supplied values.
[Description]
PointAssign returns a TPoint record initialized with the supplied values.
[Parameters]
Count=2
1=X:Integer=X value for the new TPoint.
2=Y:Integer=Y value for the new TPoint.
[Result]
A TPoint initialized with X and Y.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Points
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure PointCopy(var Dest: TPoint; const Source: TPoint);
[ShortDescr]
Copies a TPoint.
[Description]
PointCopy copies the values of the Source point into the Destination point. When
the function returns Dest is an exact copy of Source.
[Parameters]
Count=2
1=Dest:TPoint=Destination point.
2=Source:TPoint=Source point from which the values are copied.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Points
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function PointEqual(const P1, P2: TPoint): Boolean;
[ShortDescr]
Tests two points for equality.
[Description]
PointEqual compares the two supplied points.
[Parameters]
Count=2
1=P1:TPoint=First TPoint
2=P2:TPoint=Second TPoint
[Result]
If the two points are equal (identical values for X and Y) the function returns
True otherwise it returns False.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Points
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function PointIsNull(const P: TPoint): Boolean;
[ShortDescr]
Tests a point against the null point.
[Description]
PointIsNull compares P against the null point (0, 0).
[Parameters]
Count=1
1=P:TPoint=The point to test.
[Result]
If the supplied point equals the null point (a TPoint with both X and Y set to 0)
the function returns True, otherwise it returns False.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Points
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure PointMove(var P: TPoint; const DeltaX, DeltaY: Integer);
[ShortDescr]
Moves a point.
[Description]
PointMove moves the specified point by the supplied offsets.
[Parameters]
Count=3
1=P:TPoint=The point to move.
2=DeltaX:Integer=The amount by which to offset the X member of the TPoint.
3=DeltaY:Integer=The amount by which to offset the Y member of the TPoint.
[Result]
The moved point (P.X = P.X + DeltaX, P.Y = P.Y + DeltaY).
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Points
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function NullPoint: TPoint;
[ShortDescr]
Returns a null point.
[Description]
NullPoint returns a TPoint with both it's X and Y member initialized to 0.
[Result]
A TPoint initialized to (X, Y) = (0, 0).
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Points
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectIsEmpty(const R: TRect): Boolean;
[ShortDescr]
Tests if the rectangle is empty.
[Description]
RectIsEmpty tests if the specified rectangle is empty, that is, if the rectangle's
width and height are 0.
[Parameters]
Count=1
1=R:TRect=The rectangle to test.
[Result]
If the rectangle is empty the function returns True, otherwise it returns False.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure RectNormalize(var R: TRect);
[ShortDescr]
Normalizes a rectangle.
[Description]
RectNormalize normalizes the specified rectangle. A normalized rectangle is defined
as a rectangle for which Left is smaller than or equal to Right and Top is smaller
than or equal to Bottom. If these conditions are not met, RectNormalize normalizes
the rectangle by swapping Left with Right and/or Top with Bottom.
[Parameters]
Count=1
1=R:TRect=The rectangle to normalize.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectUnion(const R1, R2: TRect): TRect;
[ShortDescr]
Calculates the union of two rectangles.
[Description]
RectUnion returns the union of two rectangles. In this context, the union is
defined as the smallest rectangle that contains the two specified rectangles.
If the union is empty a null rectangle is returned.
[Parameters]
Count=2
1=R1:TRect=The first rectangle.
2=R2:TRect=The second rectangle.
[Result]
The union of the two rectangles, or a null rectangle if the union is empty.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectIsSquare(const R: TRect): Boolean;
[ShortDescr]
Tests if the rectangle is square.
[Description]
RectIsSquare tests if the specified rectangle is square (width equals height).
[Parameters]
Count=1
1=R:TRect=The rectangle to test.
[Result]
If the rectangle is square the function returns True, otherwise it returns False.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectCenter(const R: TRect): TPoint;
[ShortDescr]
Returns the center-point of the rectangle.
[Description]
RectCenter returns a TPoint which lies in the center of the rectangle. Note that
if the width or height of the rectangle is odd, then the returned point does not
lie exactly in the center of the rectangle. In such cases the point is 'rounded'
towards the top-left corner.
[Parameters]
Count=1
1=R:TRect=The rectangle.
[Result]
TPoint representing the center of the rectangle.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectEqual(const R1, R2: TRect): Boolean;
[ShortDescr]
Tests two rectangles for equality.
[Description]
RectEqual tests if two rectangle are equal.
[Parameters]
Count=2
1=R1:TRect=The first rectangle.
2=R2:TRect=The second rectangle.
[Result]
If the rectangles are equal the function returns True, otherwise it returns False.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectIsNull(const R: TRect): Boolean;
[ShortDescr]
Tests if a rectangle is a null rectangle.
[Description]
RectIsNull tests if the specified rectangle is a null rectangle.
A null rectangle is a rectangle with all it's members initialized to 0. Some
functions return a null rectangle to indicate failure.
[Parameters]
Count=1
1=R:TRect=The rectangle to test.
[Result]
If the rectangle is a null rectangle the function returns True, otherwise it returns False.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function NullRect: TRect;
[ShortDescr]
Returns a null rectangle.
[Description]
NullRect returns a null rectangle. A null rectangle is a rectangle with all its
members initialized to 0. Some functions return a null rectangle to indicate failure.
[Result]
The null rectangle.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectIsValid(const R: TRect): Boolean;
[ShortDescr]
Tests if R is a valid rectangle.
[Description]
RectIsValid tests if the specified rectangle is valid, or in Win32 terms, normalized.
A rectangle is considered valid if Left is smaller than or equal to Right and
Top is smaller than or equal to Bottom.
[Parameters]
Count=1
1=R:TRect=The rectangle to test.
[Result]
If the rectangle is valid the function returns True, otherwise it returns False.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=RectsAreValid
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectsAreValid(R: array of TRect): Boolean;
[ShortDescr]
Tests if all the rectangles in the array are valid.
[Description]
RectIsValid tests if the rectangles in the specified array are valid, or in Win32
terms, normalized. A rectangle is considered valid if Left is smaller than or
equal to Right and Top is smaller than or equal to Bottom.
[Parameters]
Count=1
1=R:TRect=The rectangles to test.
[Result]
If all rectangles are valid the function returns True, otherwise it returns False.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=RectIsValid
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectIntersectRect(const R1, R2: TRect): Boolean;
[ShortDescr]
Tests if two rectangles intersect.
[Description]
RectIntersectRect tests whether the two rectangles intersect. Note that the
function performs the test by actually calculating the intersection. Therefore,
don't write code like this: if RectIntersectRect then R := RectIntersection(...).
Instead use <REF>RectIntersection</REF> directly and compare the result against
the null rectangle.
[Parameters]
Count=2
1=R1:TRect=The first rectangle.
2=R2:TRect=The second rectangle.
[Result]
If the two rectangles intersect the function returns True, otherwise it returns False.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=RectIntersection
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectIntersection(const R1, R2: TRect): TRect;
[ShortDescr]
Calculates the intersection of two rectangles.
[Description]
RectIntersection returns the intersection of the two supplied rectangles. The
intersection is that part of the rectangles that overlap, or the part that is shared by
the two rectangles.
[Parameters]
Count=2
1=R1:TRect=The first rectangle.
2=R2:TRect=The second rectangle.
[Result]
The intersection of the two rectangles. If the two rectangles don't intersect
a null rectangle is returned.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=RectIntersectRect
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectIncludesPoint(const R: TRect; const Pt: TPoint): Boolean;
[ShortDescr]
Tests if a point lies within a rectangle.
[Description]
RectIncludesPoint tests if the specified point lies inside the boundaries defined
by the specified rectangle. The test is performed excluding the borders of the
rectangle (a point lying on a border of the rectangle causes the function to
return False).
[Parameters]
Count=2
1=R:TRect=The bounding rectangle.
2=Pt:TPoint=The point to test.
[Result]
If the point lies inside the rectangle (excluding the borders) the function returns
True, otherwise it returns False.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=RectIncludesRect
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectIncludesRect(const R1, R2: TRect): Boolean;
[ShortDescr]
Tests if one rectangle is completely embedded inside another rectangle.
[Description]
RectIncludesRect tests whether the first rectangle is completely embedded inside
the second rectangle. In other words, the function tests whether R1 is a 'subset'
of R2.
[Parameters]
Count=2
1=R1:TRect=The rectangle to test.
2=R2:TRect=The second rectangle.
[Result]
If the first rectangle is embedded inside the second the function returns True,
otherwise it returns False.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=RectIncludesPoint
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectBounds(Left, Top, Width, Height: Integer): TRect;
[ShortDescr]
Initializes a rectangle by bounds.
[Description]
RectBounds returns a rectangle with its top-left corner set to the combination
of Left and Top and with a width and height of Width and Height respectively.
[Parameters]
Count=4
1=Left:Integer=Left coordinate of the rectangle.
2=Top:Integer=Top coordinate of the rectangle.
3=Width:Integer=Width of the rectangle.
4=Height:Integer=Height of the rectangle.
[Result]
A TRect initialized with the specified coordinates/dimensions.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=RectAssignPoints
2=RectCopy
3=RectAssign
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectAssign(Left, Top, Right, Bottom: Integer): TRect;
[ShortDescr]
Initializes a rectangle by the individual coordinates.
[Description]
RectAssign returns a TRect with it's members initialized to the individually
specified coordinates.
[Parameters]
Count=4
1=Left:Integer=Left coordinate of the rectangle.
2=Top:Integer=Top coordinate of the rectangle.
3=Right:Integer=Right coordinate of the rectangle.
4=Bottom:Integer=Bottom coordinate of the rectangle.
[Result]
A TRect initialized with the coordinates.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=RectAssignPoints
2=RectCopy
3=RectBounds
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectAssignPoints(const TopLeft, BottomRight: TPoint): TRect;
[ShortDescr]
Initializes a rectangle by TPoints.
[Description]
RectAssignPoints returns a rectangle initialized to the specified top-left and
bottom-right coordinate points.
[Parameters]
Count=2
1=TopLeft:TPoint=Top-left coordinate of the rectangle.
2=BottonRight:TPoint=Bottom-right coordinate of the rectangle.
[Result]
A TRect initialized to the specified points.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=RectAssign
2=RectCopy
3=RectBounds
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectCopy(var Dest: TRect; const Source: TRect);
[ShortDescr]
Copies a rectangle.
[Description]
RectCopy copies the Source rectangle's coordinates into the Dest(ination) rectangle.
[Parameters]
Count=2
1=Dest:TRect=Destination rectangle which receives a copy of Source.
2=Source:TRect=Source rectangle.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=3
1=RectAssign
2=RectAssignPoints
3=RectBounds
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure RectMove(var R: TRect; DeltaX, DeltaY: Integer);
[ShortDescr]
Moves the specified rectangle by the specified offsets.
[Description]
RectMove moves the specified rectangle by the specified offsets. This does not
affect the width and height of the rectangle.
[Parameters]
Count=3
1=R:TRect=The rectangle to move.
2=DeltaX:Integer=The amount to move the rectangle in the horizontal direction.
3=DeltaY:Integer=The amount to move the rectangle in the vertical direction.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=RectMoveTo
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure RectMoveTo(var R: TRect; X, Y: Integer);
[ShortDescr]
Moves the rectangle to the specified coordinates.
[Description]
RectMoveTo moves the rectangle to the coordinates specified by X and Y. This does
not affect the width and height of the rectangle.
[Parameters]
Count=3
1=R:TRect=The rectangle to move
2=X:Integer=The new X coordinate of the top-left corner of the rectangle.
3=Y:Integer=The new Y coordinate of the top-left corner of the rectangle.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=RectMove
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure RectGrow(var R: TRect; Delta: Integer);
[ShortDescr]
Expands a rectangle by the specified amount.
[Description]
RectGrow expands the rectangle with Delta in each direction. As such, all members
of the TRect record are altered. Left becomes Left - Delta, Right becomes Right + Delta
and so forth. Note that specifying a negative Delta effectively shrinks the
rectangle. However, this may leave you with a denormalized rectangle!
[Parameters]
Count=2
1=R:TRect=The rectangle to expand.
2=Delta:Integer=The amount with which to expand the rectangle.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=2
1=RectGrowX
2=RectGrowY
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure RectGrowX(var R: TRect; Delta: Integer);
[ShortDescr]
Expands the horizontal dimension of a rectangle by the specified amount.
[Description]
RectGrowX expands the horizontal dimension of the rectangle with Delta in each
direction. As such, Left becomes Left - Delta, Right becomes Right + Delta.
Note that specifying a negative Delta effectively shrinks the rectangle. However,
this may leave you with a denormalized rectangle!
[Parameters]
Count=2
1=R:TRect=The rectangle to expand.
2=Delta:Integer=The amount with which to expand the rectangle.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=2
1=RectGrow
2=RectGrowY
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure RectGrowY(var R: TRect; Delta: Integer);
[ShortDescr]
Expands the vertical dimension of a rectangle by the specified amount.
[Description]
RectGrowY expands the vertical dimension of the rectangle with Delta in each
direction. As such, Top becomes Top - Delta, Bottom becomes Bottom + Delta.
Note that specifying a negative Delta effectively shrinks the rectangle. However,
this may leave you with a denormalized rectangle!
[Parameters]
Count=2
1=R:TRect=The rectangle to expand.
2=Delta:Integer=The amount with which to expand the rectangle.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=2
1=RectGrow
2=RectGrowX
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectHeight(const R: TRect): Integer;
[ShortDescr]
Returns the height of a rectangle.
[Description]
RectHeight returns the height, in pixels, of the specified rectangle.
[Parameters]
Count=1
1=R:TRect=The rectangle for which to calculate the height.
[Result]
The height of the rectangle in pixels.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=RectWidth
<DECL>--------------------------------------------------------------------------
[Declaration]
function RectWidth(const R: TRect): Integer;
[ShortDescr]
Returns the width of a rectangle.
[Description]
RectWidth returns the width, in pixels, of the specified rectangle.
[Parameters]
Count=1
1=R:TRect=The rectangle for which to calculate the width.
[Result]
The width of the rectangle in pixels.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Rectangles
Author=Pelle F. S. Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=RectHeight
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure DrawBitmap(DC: HDC; Bitmap: HBitMap; X, Y, Width, Height: Integer);
[ShortDescr]
Draws a bitmap to a device context.
[Description]
DrawBitmap draws the specified bitmap to the specified device context at the
position indicated by (X, Y) and with the width and height specified by Width
and Height respectively. If the bitmap's size is different from the supplied
Width and Height the bitmap is automatically stretched.
[Parameters]
Count=6
1=DC:HDC=Device context to draw to (e.g. Form1.Canvas.Handle).
2=Bitmap:HBitmap=Handle of the bitmap to draw.
3=X:Integer=Horizontal position of the upper left corner in the destination DC where to draw the bitmap.
4=Y:Integer=Vertical position of the upper left corner in the destination DC where to draw the bitmap.
5=Width:Integer=Width of the destination bitmap.
6=Height:Integer=Height of the destination bitmap.
[Quick Info]
BCB=3,4,5
Unit=JclGraphics
Category=Graphics
Author=Charlie Calvert;ccalvert@inprise.com
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure BitmapToJPeg(const FileName: string);
[ShortDescr]
Converts a bitmap to a JPEG.
[Description]
BitmapToJPeg converts a bitmap file to a JPEG file. The destination file is
saved with the same name as the source bitmap file but with the extension '.jpg'.
If the function fails at any point it raises an exception.
[Parameters]
Count=1
1=FileName:string=Name of the bitmap file to convert to a JPEG image.
[Quick Info]
BCB=3,4,5
Unit=JclGraphics
Category=Graphics
SubCat=Conversion
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=1
1=JPegToBitmap
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure JPegToBitmap(const FileName: string);
[ShortDescr]
Converts a JPEG to a bitmap.
[Description]
JPegToBitmap converts a JPEG image to a bitmap file. The destination file is
saved with the same name as the source file but with the extension '.bmp'. If the
function fails at any point it raises an exception.
[Parameters]
Count=1
1=FileName:string=Name of the JPEG image file to convert to a bitmap.
[Quick Info]
BCB=3,4,5
Unit=JclGraphics
Category=Graphics
SubCat=Conversion
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
[SeeAlso]
Count=1
1=BitmapToJpeg
<DECL>--------------------------------------------------------------------------
[Declaration]
function ExtractIconCount(const FileName: string): Integer;
[ShortDescr]
Returns the number of icons in a file.
[Description]
ExtractIconCount returns the number of icons that exist in the specified file.
The function is capable of detecting the number of icons in an executable file,
a dynamic link library or an icon file. In the case of a .exe or .dll the function
returns the number of RT_GROUP_ICON resources and in case of a .ico file it returns
1.
[Parameters]
Count=1
1=FileName:string=Fully qualified name of the file for which to count the number
of icons. This can be any executable file, dynamic link library or icon file.
[Result]
The number of icons in the specified file. If the file does not contain icons
the result is 0.
[Quick Info]
BCB=3,4,5
Unit=JclGraphics
Category=Graphics
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function BitmapToIcon(Bitmap: HBITMAP; cx, cy: Integer): HICON;
[ShortDescr]
Converts a bitmap to an icon.
[Description]
BitmapToIcon converts the specified bitmap (identified by handle) to an icon.
[Parameters]
Count=3
1=Bitmap:HBTIMAP=Handle of the bitmap to convert.
2=cx:Integer=Width of the bitmap.
3=cy:Integer=Height of the bitmap.
[Result]
Handle to the icon or 0 on failure. Caller is responsible for eventually releasing
the icon resource by calling DestroyIcon.
[Quick Info]
BCB=3,4,5
Unit=JclGraphics
Category=Graphics
SubCat=Conversion
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
function IconToBitmap(Icon: HICON): HBITMAP;
[ShortDescr]
Converts an icon to a bitmap.
[Description]
IconToBitmap converts the specified icon, represented by handle, to a bitmap.
[Parameters]
Count=1
1=Icon:HICON=Icon to convert.
[Result]
Handle to the bitmap or 0 on failure. The caller is responsible for freeing the
resources associated with this bitmap by calling DeleteObject.
[Quick Info]
BCB=3,4,5
Unit=JclGraphics
Category=Graphics
SubCat=Conversion
Author=Marcel van Brakel;brakelm@bart.nl
Delphi=3,4,5
Windows NT/2000=Requires Windows NT 3.1 or later.
Windows 95/98=Requires Windows 95 or later.
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Stretch(NewWidth, NewHeight: Cardinal; Filter: TResamplingFilter;
  Radius: Single; Source, Target: TBitmap);
procedure Stretch(NewWidth, NewHeight: Cardinal; Filter: TResamplingFilter;
  Radius: Single; Source: TBitmap);
[ShortDescr]
Scales a bitmap to another bitmap.
[Description]
Scales the source bitmap to the given size (NewWidth, NewHeight) and stores the Result
in Target. Filter describes the filter function to be applied and Radius the size of
the filter area. If Radius = 0 then the recommended filter area will be used
(see DefaultFilterRadius). With the filters you can determine the quality and the speed
of the conversion, use a Box or Triangle filter for fast previews and a Lanczos3 or Bell
filter for better quality.
[Parameters]
Count=6
1=NewWidth:Cardinal=The new width of the target bitmap.
2=NewHeight:Cardinal=The new height of the target bitmap.
3=Filter:TResamplingFilter=The filter to be used.
4=Radius:Single=The radius in pixels that will influence the current pixel. This can be a
fractional to use partial pixels.
5=Source:TBitmap=The source bitmap. If only source is specified then source will be
replaced with the resulting bitmap.
6=Target:TBitamp=The target bitmap.
[Quick Info]
Unit=JclGraphics
Category=Graphics
Author=Mike Lischke;public@lischke-online.de
Delphi=3,4,5
BCB=3,4,5
[SeeAlso]
Count=1
1=TResamplingFilter
<DECL>--------------------------------------------------------------------------
[Declaration]
TResamplingFilter = (sfBox, sfTriangle, sfHermite, sfBell, sfSpline,
  sfLanczos3, sfMitchell);
[ShortDescr]
Filters for stretch function.
[Description]
The filters used in the resampling code differ mainly in complexity but also in the way
they calculate pixel contributions. These contributions are used to calculate the final pixel
and depend on the original value and the values of neighbor pixels. How many pixel are taken
into the calculation is determined by the filter radius, which essentially describes the number
of pixels around a center pixel (the radius can be fractional to use partial pixels too).
The reason why there are several filters instead of only one is that you can trade off
speed against quality. For nearly interactive resampling only the box (and perhaps the triangle)
filters are suitable. The quality resulting from those filters is only on average level.
Filters like Lanczos3 or Bell produce much better results which are well comparable with those of
Photoshop's bicubic interpolation.
[Quick Info]
Unit=JclGraphics
Category=Graphics
Author=Mike Lischke;public@lischke-online.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetAntialiasedBitmap(const Bitmap: TBitmap): TBitmap;
[ShortDescr]
Antialiases a bitmap.
[Description]
Antialiases a bitmap.
[Parameters]
Count=1
1=Bitmap:TBitmap=The bitmap to be antialiased.
[Result]
An antialiased true color bitmap shrunk 2 times on each dimension. Output bitmap is
created inside the function and should be manually freed.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Conversion
Author=Marcin Wieczorek (T-1000);wieczor@polbox.com
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure CIED65ToCIED50(var X, Y, Z: Extended);
[ShortDescr]
Converts values of the XYZ color space using the D65 white point to D50 white point.
[Description]
Converts values of the XYZ color space using the D65 white point to D50 white point.
The values were taken from www.srgb.com/hpsrgbprof/sld005.htm
[Parameters]
Count=3
1=X:Extended=X Color D65.
2=Y:Extended=Y Color D65.
3=Z:Extended=Z Color D65.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Mike Lischke;public@lischke-online.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Gray16(Source, Target: Pointer; BitsPerSample: Byte; Count: Cardinal);
[ShortDescr]
Converts each color component from a 16 bits per sample to 8 bit used in Windows DIBs.
[Description]
Converts each color component from a 16 bits per sample to the 8 bits used in Windows DIBs.
Count is the number of entries in Source and Target.
[Parameters]
Count=3
1=Source:Pointer=The source pointer to a stream of 16 bit colors.
2=Target:Pointer=The target pointer to a stream of 8 bit colors.
4=Count:Cardinal=Number of samples to convert.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Mike Lischke;public@lischke-online.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure CMYK2BGR(Source, Target: Pointer; BitsPerSample: Byte; Count: Cardinal); overload;
procedure CMYK2BGR(C, M, Y, K, Target: Pointer; BitsPerSample: Byte; Count: Cardinal); overload;
[ShortDescr]
Converts a stream of Count CMYK values to BGR.
[Description]
Converts a stream of Count CMYK values to BGR.
[Parameters]
Count=4
1=Source(C,M,Y,K):Pointer=Source Pointer of the stream of CMYK records, these are records of 4 bytes
or 4 words representing the CMYK colors. These can also be separate C, Y, M and K streams, then each
stream represents a byte or word array of color components.
2=Target:Pointer=Target pointer of the stream of BRG records, this are 3 byte records representing
BGR colors
3=BitsPerSample:Byte=The bits per color component of the source stream, this can be 8 or 16 bits.
4=Count:Cardinal=Number of samples to convert.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Mike Lischke;public@lischke-online.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure CIELAB2BGR(Source, Target: Pointer; BitsPerSample: Byte; Count: Cardinal); overload;
procedure CIELAB2BGR(LSource, aSource, bSource: PByte; Target: Pointer; BitsPerSample: Byte; Count: Cardinal); overload;
[ShortDescr]
Conversion of the CIE L*a*b color space to RGB using a two step approach assuming a D65 white point,
first a conversion to CIE XYZ is performed and then from there to RGB.
[Description]
Conversion of the CIE L*a*b color space to RGB using a two step approach assuming a D65 white point,
first a conversion to CIE XYZ is performed and then from there to RGB.
[Parameters]
Count=3
1=Source:Pointer=The source pointer to a stream of CIELAB records, the size of the records is
always 3 bytes per record.
2=Target:Pointer=The target pointer to a stream of BGR records, the size is always 3 bytes per record.
3=Count:Cardinal=Number of samples to convert.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Mike Lischke;public@lischke-online.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure RGB2BGR(Source, Target: Pointer; BitsPerSample: Byte; Count: Cardinal); overload;
procedure RGB2BGR(R, G, B, Target: Pointer; BitsPerSample: Byte; Count: Cardinal); overload;
[ShortDescr]
Reorders a stream of "Count" RGB values to BGR, additionally an eventual sample size adjustment is done.
[Description]
Reorders a stream of "Count" RGB values to BGR, additionally an eventual sample size adjustment is done.
[Parameters]
Count=4
1=Source:Pointer=Source pointer to a stream of RGB records, the records in the stream can be 3 bytes or 3
words. This can also be a separate R, G and B stream of single byte or word color components.
2=Target:Pointer=Target pointer to a stream of BGR records that are 3 bytes long.
3=BitsPerSample:Byte=The bits per sample of the source stream, this can be 8 or 16 bits.
4=Count:Cardinal=Number of samples to convert.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Mike Lischke;public@lischke-online.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure RGBA2BGRA(Source, Target: Pointer; BitsPerSample: Byte; Count: Cardinal);
[ShortDescr]
Reorders a stream of "Count" RGBA values to BGRA, additionally an eventual sample
size adjustment is done.
[Description]
Reorders a stream of "Count" RGBA values to BGRA, additionally an eventual sample
size adjustment is done.
[Parameters]
Count=4
1=Source:Pointer=The source pointer to a stream of RGBA records, the size of the records
is 4 bytes or 4 words.
2=Target:Pointer=The pointer to the target stream of BGRA records, the size of the records is 4 bytes per record.
3=BitsPerSample:Byte=The bits per sample of the source stream, this can be 8 or 16 bits.
4=Count:Cardinal=Number of samples to convert.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Mike Lischke;public@lischke-online.de
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure WinColor2OpenGLColor(Color : TColor; out Red, Green, Blue: Float);
[ShortDescr]
Converts TColor to OpenGLColor.
[Description]
Conversion of TColor to OpenGLColor, the color channels of OpenGL are floats between 0.0 and 1.0.
[Parameters]
Count=4
1=Color:TColor=The color to convert.
2=Red:Float=The Red OpenGLColor channel between 0.0 and 1.0.
3=Green:Float=The Green OpenGLColor channel between 0.0 and 1.0.
4=Blue:Float=The Blue OpenGLColor channel between 0.0 and 1.0.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function OpenGLColor2WinColor(Red, Green, Blue : Float) : TColor;
[ShortDescr]
Converts OpenGLColor to TColor.
[Description]
Conversion of OpenGLColor to TColor, the color channels of OpenGL are floats between 0.0 and 1.0.
[Parameters]
Count=3
2=Red:Float=The Red OpenGLColor channel between 0.0 and 1.0.
3=Green:Float=The Green OpenGLColor channel between 0.0 and 1.0.
4=Blue:Float=The Blue OpenGLColor channel between 0.0 and 1.0.
[Result]
The windows color.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Colors
Author=Pelle Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TJclDesktopCanvas = class(TCanvas);
[ShortDescr]
Access the desktop canvas.
[Description]
This class gives you access to the desktop canvas. It inherits everything from the canvas
class. When using this canvas don't change the handle of the canvas this will remove the
functionality of the class.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=TJclDesktopCanvas
Author=Pelle Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create;
[ShortDescr]
Creates the desktop canvas class.
[Description]
Gets the desktop graphics device handle from the operating system and initializes the canvas.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclGraphics
Category=Graphics
SubCat=TJclDesktopCanvas
Author=Pelle Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
destructor Destroy; override;
[ShortDescr]
Destroys the desktop canvas class.
[Description]
Destroys the desktop canvas class.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclGraphics
Category=Graphics
SubCat=TJclDesktopCanvas
Author=Pelle Liljendal;pelle@liljendal.dk
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TColor32 = type Longword;
PColor32 = ^TColor32;
[ShortDescr]
TColor32 represents an ARGB color quad.
[Description]
TColor32 represents an ARGB color quad.
<P>This order is different from the ABGR pixel format used by most Windows API functions
and implemented in Delphi as a TColor type. Several functions are provided to convert
colors between different standards.
<P>The alpha channel is responsible for pixels opacity: zero value corresponds to
complete transparency, and the value of 255 corresponds to completely opaque pixels.
<P>Do not use TColor-typed values with Graphics32 directly, use the provided conversion functions,
e.g.:
<P>Bitmap32.SetPixel(10, 10, Color32(clBtnFace));
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Types
Author=Alex Denissov;denisso@uwindsor.ca
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TColor32Array = array [0..0] of TColor32;
PColor32Array = ^TColor32Array;
TArrayOfColor32 = array of TColor32;
[ShortDescr]
TColor32 Arrays.
[Description]
TColor32 Arrays.
<P>Do not confuse PColor32Array and TArrayOfColor32 types; while the first holds the pointer
to a memory location, the second is a fully functional dynamic array.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Types
Author=Alex Denissov;denisso@uwindsor.ca
Delphi=3,4,5
BCB=3,4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TPalette32 = array [Byte] of TColor32;
PPalette32 = ^TPalette32;
[ShortDescr]
TPalette32 types are mostly used to simulate palette-based operations.
[Description]
TPalette32 types are mostly used to simulate palette-based operations.
[Quick Info]
Unit=JclGraphics
Category=Graphics
SubCat=Types
Author=Alex Denissov;denisso@uwindsor.ca
Delphi=3,4,5
BCB=3,4,5
