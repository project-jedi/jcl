<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsAlpha(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is an alphabetic character.
[Description]
UnicodeIsAlpha tests whether the specified unicode codepoint is an alphabetic
character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is an alphabetical character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsDigit(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a digit.
[Description]
UnicodeIsDigit tests whether the specified unicode codepoint is a digit.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a digit the function returns True, otherwise
the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsAlphaNum(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is an alphanumerical character.
[Description]
UnicodeIsAlphaNum tests whether the specified unicode codepoint is an alphanumerical
character. That is, it tests for both alphabetical characters and numbers.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is an alphanumerical character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsControl(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a control character.
[Description]
UnicodeIsControl tests whether the specified unicode codepoint is a control
character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a control character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsSpace(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a spacing character.
[Description]
UnicodeIsSpace tests whether the specified unicode codepoint is a spacing
character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a spacing character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsWhiteSpace(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a white space character.
[Description]
UnicodeIsWhiteSpace tests whether the specified unicode codepoint is a white space
character. This is similar to UnicodeIsSpace with the addition of tabulator,
new line and so forth.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a white space character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsBlank(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a space character.
[Description]
UnicodeIsBlank tests whether the specified unicode codepoint is a space
character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a space character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsPunctuation(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a punctuation mark.
[Description]
UnicodeIsPunctuation tests whether the specified unicode codepoint is a punctuation
mark.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a punctuation mark the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsGraph(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a graphical character.
[Description]
UnicodeIsGraph tests whether the specified unicode codepoint is a graphical
character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a graphical character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsPrintable(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a printable character.
[Description]
UnicodeIsPrintable tests whether the specified unicode codepoint is a printable
character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a printable character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsUpper(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is uppercase.
[Description]
UnicodeIsUpper tests whether the specified unicode codepoint is an uppercase
character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is an uppercase character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsLower(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is lowercase.
[Description]
UnicodeIsLower tests whether the specified unicode codepoint is a lowercase
character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a lowercase character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsTitle(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a titlecased character.
[Description]
UnicodeIsTitle tests whether the specified unicode codepoint is a titlecase
character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a titlecased character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsHexDigit(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a hexadecimal digit.
[Description]
UnicodeIsHexDigit tests whether the specified unicode codepoint is a hexadecimal digit.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a hexadecimal digit the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsIsoControl(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is an ISO control character.
[Description]
UnicodeIsIsoControl tests whether the specified unicode codepoint is an ISO control
character (ordinal value smaller than 32).
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is an ISO control character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsFormatControl(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a format control character.
[Description]
UnicodeIsFormatControl tests whether the specified unicode codepoint is a format
control character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a format control character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsSymbol(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a symbol.
[Description]
UnicodeIsSymbol tests whether the specified unicode codepoint is a symbol
character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a symbol character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsNumber(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a number or digit.
[Description]
UnicodeIsNumber tests whether the specified unicode codepoint is a number
or digit.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a number or digit the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsNonSpacing(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is non-spacing.
[Description]
UnicodeIsNonSpacing tests whether the specified unicode codepoint is a non-spacing
character.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a non-spacing character the function returns True,
otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsOpenPunctuation(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is an open/left punctuation.
[Description]
UnicodeIsOpenPunctuation tests whether the specified unicode codepoint is an open/left
punctuation character. For example '['.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is an open/left punctuation character the function
returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsClosePunctuation(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a closing/right punctuation character.
[Description]
UnicodeIsClosePunctuation tests whether the specified unicode codepoint is a closing/right
punctuation character. For example ']'.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a closing/right punctuation character the function
returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsInitialPunctuation(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is an initial punctuation character.
[Description]
UnicodeIsInitialPunctuation tests whether the specified unicode codepoint is an initial
punctuation character. For example U+2018 LEFT SINGLE QUOTATION MARK.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is an initial punctuation character the function
returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsFinalPunctuation(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a final punctuation character.
[Description]
UnicodeIsFinalPunctuation tests whether the specified unicode codepoint is a final
punctuation control character. For example U+2019 RIGHT SINGLE QUOTATION MARK.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a final punctuation character the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsCased(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a cased character.
[Description]
UnicodeIsCased tests whether the specified unicode codepoint is a cased
character, i.e. either lower case, title case, upper case or unique upper case.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a cased character the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsComposed(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a composite character.
[Description]
UnicodeIsComposed tests whether the specified unicode codepoint is a composite
character. That is it returns whether the character can be decomposed into a set
of other characters (eg an &uuml; u umlaut is a composite character).
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a composite character the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsQuotationMark(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a quotation mark.
[Description]
UnicodeIsQuotationMark tests whether the specified unicode codepoint is a quotation
mark. For example ', " etc.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a quotation mark the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsSymmetric(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is symmetric.
[Description]
UnicodeIsSymmetric tests whether the specified unicode codepoint is a symmetric
character. That is, whether it has an opposite form. An example of a symmetric
character is '<' (the opposite would be '>').
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a symmetric character the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsMirroring(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a final mirroring character.
[Description]
UnicodeIsMirroring tests whether the specified unicode codepoint is a mirroring
character (superset of symmetric).
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a mirroring character the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsNonBreaking(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a non breaking character.
[Description]
UnicodeIsNonBreaking tests whether the specified unicode codepoint is a non breaking
character, for example a non breaking space.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a non breaking character the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsMark(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a mark of some kind.
[Description]
UnicodeIsMark tests whether the specified unicode codepoint is a mark of some
kind.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a mark character the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsModifier(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a modifier.
[Description]
UnicodeIsModifier tests whether the specified unicode codepoint is a modifier.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a modifier character the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsLetterNumber(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a number represented by a letter.
[Description]
UnicodeIsLetterNumber tests whether the specified unicode codepoint is a number by a
letter.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a letter character representing a number the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsConnectionPunctuation(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a connection punctuation.
[Description]
UnicodeIsConnectionPunctuation tests whether the specified unicode codepoint is
a connection punctuation, for example an underscore.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a connection punctuation character the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsMath(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a math character.
[Description]
UnicodeIsMath tests whether the specified unicode codepoint is a math
character, for example a hyphen.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a math character the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsDash(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a dash punctuation.
[Description]
UnicodeIsDash tests whether the specified unicode codepoint is a dash
punctuation, for example a plus sign.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a dash punctuation character the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsCurrency(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a currency symbol.
[Description]
UnicodeIsCurrency tests whether the specified unicode codepoint is a currency symbol,
for example the dollar sign.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a currency symbol the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsModifierSymbol(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a modifier symbol.
[Description]
UnicodeIsModifierSymbol tests whether the specified unicode codepoint is a
modifier symbol, for example the grave accent.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a modifier symbol the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsNonSpacingMark(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a non-spacing mark.
[Description]
UnicodeIsNonSpacingMark tests whether the specified unicode codepoint is a
non-spacing mark, for example the combining grave accent.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a non-spacing mark the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsSpacingMark(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a spacing mark.
[Description]
UnicodeIsSpacingMark tests whether the specified unicode codepoint is a
spacing mark, for example the Bengali vowel sign AA.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a spacing mark the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsEnclosing(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is enclosing.
[Description]
UnicodeIsEnclosing tests whether the specified unicode codepoint is enclosing,
for example the enclosing box.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is enclosing the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsPrivate(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is from the private use area.
[Description]
UnicodeIsPrivate tests whether the specified unicode codepoint is from the
private use area.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is from the private use area the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsSurrogate(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is one of the surrogate codes.
[Description]
UnicodeIsSurrogate tests whether the specified unicode codepoint is one of the
surrogate codes.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is one of the surrogate codes the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsLineSeparator(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a line separator character.
[Description]
UnicodeIsLineSeparator tests whether the specified unicode codepoint is a line
separator character.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a line separator character the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsParagraphSeparator(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a paragraph separator character.
[Description]
UnicodeIsParagraphSeparator tests whether the specified unicode codepoint is a
paragraph separator character.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a paragraph separator character the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsIdentifierStart(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is allowed as initial character of an identifier.
[Description]
UnicodeIsIdentifierStart tests whether the specified unicode codepoint is a
character that can begin an identifier, ie. the character must be a letter
(upper-, lower- or titlecase or other) or a letter representing a number.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint can begin an identifier the
function returns True, otherwise the function returns False.
[Notes]
Count=1
1=UnicodeIsIdentifierStart could be replaced by (UnicodeIsAlpha <B>or</B>
UnicodeIsLetterNumber) <B>and not</B> UnicodeIsModifier
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsIdentifierPart(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is allowed as part of an identifier.
[Description]
UnicodeIsIdentifierPart tests whether the specified unicode codepoint is a
character that can be in an identifier, ie. the character must be a letter
(upper-, lower- or titlecase or other), a letter representing a number,
a mark (non-spacing or spacing combining), a decimal digit, a connecting
punctuation or a format control character.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint can be in an identifier the
function returns True, otherwise the function returns False.
[Notes]
Count=1
1=UnicodeIsIdentifierPart could be replaced by (UnicodeIsIdentifierStart <B>or</B>
UnicodeIsNonSpacingMark <B>or</B> UnicodeIsSpacingMark <B>or</B> UnicodeIsDigit <B>or</B>
UnicodeIsConnectionPunctuation <B>or</B> UnicodeIsFormatControl
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsDefined(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is defined.
[Description]
UnicodeIsDefined tests whether the specified unicode codepoint is defined (ie.
it appears in one of the data files).
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is defined the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsUndefined(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is undefined.
[Description]
UnicodeIsUndefined tests whether the specified unicode codepoint is undefined
(ie. a non-unicode character).
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is undefined the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsHan(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a Han ideograph.
[Description]
UnicodeIsHan tests whether the specified unicode codepoint is a Han ideograph.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a Han ideograph the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsHangul(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests whether the codepoint is a Hangul syllable.
[Description]
UnicodeIsHangul tests whether the specified unicode codepoint is a pre-composed
Hangul syllable.
[Parameters]
Count=1
1=C:UCS4=The unicode codepoint (character) to test.
[Result]
If the specified codepoint is a Hangul syllable the
function returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Character test routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeNumberLookup(Code: <REF TARGET"..\Types\PUCS4">UCS4</REF>; var Number: <REF TARGET"..\Types\TUcNumber">TUcNumber</REF>): Boolean;
[ShortDescr]
Searches for the given code and returns its number equivalent (if there is one).
[Description]
UnicodeNumberLookup searches for the given code and returns its number equivalent
(if there is one). Typical cases are: '1/6' (U+2159), '3/8' (U+215C),
'XII' (U+216B) etc.
[Parameters]
Count=1
1=Code:UCS4=The unicode codepoint (character) to locate number equivalent of.
[Result]
True if a number could be found.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Low level character routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=3
1=UnicodeToUpper
2=UnicodeToLower
3=UnicodeToTitle
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeToUpper(Code: <REF TARGET"..\Types\PUCS4">UCS4</REF>): <REF TARGET"..\Types\PUCS4">TUCS4Array</REF>;
[ShortDescr]
Converts a codepoint to uppercase.
[Description]
UnicodeToUpper converts the specified unicode codepoint (character) to uppercase.
[Parameters]
Count=1
1=Code:UCS4=The codepoint to convert.
[Result]
The uppercased codepoint(s).
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Low level character routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=3
1=UnicodeNumberLookup
2=UnicodeToLower
3=UnicodeToTitle
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeToLower(Code: <REF TARGET"..\Types\PUCS4">UCS4</REF>): <REF TARGET"..\Types\PUCS4">TUCS4Array</REF>;
[ShortDescr]
Converts a codepoint to lowercase.
[Description]
UnicodeToLower converts the specified unicode codepoint (character) to lowercase.
[Parameters]
Count=1
1=Code:UCS4=The codepoint to convert.
[Result]
The lowercased codepoint(s).
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Low level character routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=3
1=UnicodeNumberLookup
2=UnicodeToUpper
3=UnicodeToTitle
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeToTitle(Code: <REF TARGET"..\Types\PUCS4">UCS4</REF>): <REF TARGET"..\Types\PUCS4">TUCS4Array</REF>;
[ShortDescr]
Converts a codepoint to title case.
[Description]
UnicodeToUpper converts the specified unicode codepoint (character) to title case.
[Parameters]
Count=1
1=Code:UCS4=The codepoint to convert.
[Result]
The title cased codepoint(s).
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Low level character routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=3
1=UnicodeNumberLookup
2=UnicodeToUpper
3=UnicodeToLower
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsRightToLeft(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests a Unicode character against right-to-left directionality.
[Description]
UnicodeIsRightToLeft returns whether the specified character has (strong) right-to-left
directionality. Examples of characters that have right-to-left directionality
are the Arabic and Hebrew alphabet and punctuation specific to those scripts.
[Parameters]
Count=1
1=C:UCS4=The Unicode character to test.
[Result]
If the specified unicode character has right-to-left directionality the function
returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Directionality
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=5
1=UnicodeIsLeftToRight
2=UnicodeIsStrong
3=UnicodeIsWeak
4=UnicodeIsNeutral
5=UnicodeIsSeparator
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsLeftToRight(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests a Unicode character against left-to-right directionality.
[Description]
UnicodeIsLeftToRight returns whether the specified character has (strong) left-to-right
directionality. Most alphabetic and syllabic, as well as all Han ideographic
characters, have left-to-right directionality.
[Parameters]
Count=1
1=C:UCS4=The Unicode character to test.
[Result]
If the specified unicode character has left-to-right directionality the function
returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Directionality
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=5
1=UnicodeIsRightToLeft
2=UnicodeIsStrong
3=UnicodeIsWeak
4=UnicodeIsNeutral
5=UnicodeIsSeparator
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsStrong(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests a Unicode character for strong directionality.
[Description]
UnicodeIsStrong returns whether the specified character has strong directionality.
Strong directionality means that it has either left-to-right or right-to-left
directionality. In contrast there are also characters that exhibit weak or neutral
directionality. Examples of characters with strong directionality are the Arabic
and Hebrew alphabets as well as most alphabetic, syllable, and Han ideographic characters.
[Parameters]
Count=1
1=C:UCS4=The Unicode character to test.
[Result]
If the specified unicode character has strong directionality the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Directionality
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=5
1=UnicodeIsRightToLeft
2=UnicodeIsLeftToRight
3=UnicodeIsWeak
4=UnicodeIsNeutral
5=UnicodeIsSeparator
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsWeak(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests a Unicode character for weak directionality.
[Description]
UnicodeIsWeak returns whether the specified character has weak directionality.
Examples of characters with weak directionality are numbers and number separators
and terminators. In contrast there are also characters that exhibit strong or neutral
directionality.
[Parameters]
Count=1
1=C:UCS4=The Unicode character to test
[Result]
If the specified unicode character has weak directionality the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Directionality
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=5
1=UnicodeIsRightToLeft
2=UnicodeIsLeftToRight
3=UnicodeIsStrong
4=UnicodeIsNeutral
5=UnicodeIsSeparator
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsNeutral(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests a Unicode character for neutral directionality.
[Description]
UnicodeIsNeutral returns whether the specified character has neutral directionality.
Examples of characters with neutral directionality are spaces, punctuation and symbols.
In contrast there are also characters that exhibit strong or weak directionality.
[Parameters]
Count=1
1=C:UCS4=The Unicode character to test
[Result]
If the specified unicode character has neutral directionality the function returns
True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Directionality
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=5
1=UnicodeIsRightToLeft
2=UnicodeIsLeftToRight
3=UnicodeIsStrong
4=UnicodeIsWeak
5=UnicodeIsSeparator
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeIsSeparator(C: <REF TARGET"..\Types\PUCS4">UCS4</REF>): Boolean;
[ShortDescr]
Tests a Unicode character against separator directionality.
[Description]
UnicodeIsSeparator tests whether the specified character is a block or segment
separator. Examples of separators are the line separator (U+2028) and the
horizontal tab (U+0009).
[Parameters]
Count=1
1=C:UCS4=The Unicode character to test
[Result]
If the specified unicode character is a block or segment separator the function
returns True, otherwise the function returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Directionality
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=5
1=UnicodeIsRightToLeft
2=UnicodeIsLeftToRight
3=UnicodeIsStrong
4=UnicodeIsWeak
5=UnicodeIsNeutral
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideStringOfChar(C: WideChar; Count: Cardinal): WideString;
[ShortDescr]
[Description]
WideStringOfChar returns a string of length Count with each character initialized
to the specified character C.
[Parameters]
Count=2
1=C:WideChar=The character to initialize the string with.
2=Count:Cardinal=The length of the string.
[Result]
A string of length Count with all characters set to C.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideQuotedStr(const S: WideString; Quote: WideChar): WideString;
[ShortDescr]
Returns a quoted string.
[Description]
WideQuotedStr returns a copy of S with the specified Quote character inserted at
the beginning and end of the string.
[Parameters]
Count=2
1=S:WideString=The string to convert to a quoted string.
2=Quote:WideChar=The character to use as quote.
[Result]
The quoted version of the supplied string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideExtractQuotedStr(var Src: PWideChar; Quote: WideChar): WideString;
[ShortDescr]
Extracts a string enclosed in quote characters.
[Description]
WideExtractQuotedStr removes the Quote characters from the beginning and end
of a quoted string, and reduces pairs of Quote characters within the quoted
string to a single character. If the first character in Src is not the Quote
character, the function returns an empty string.  The function copies
characters from the Src to the result string until the second solitary
Quote character or the first null character in Src. The Src parameter is
updated to point to the first character following the quoted string.  If
the Src string does not contain a matching end Quote character, the Src
parameter is updated to point to the terminating null character in Src.
[Parameters]
Count=2
1=Src:PWideChar=The source string from which to remove quotes.
2=Quote:WideChar=Denotes the character used as a quote.
[Result]
The string without the quotes.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideTrim(const S: WideString): WideString;
[ShortDescr]
Trims leading and trailing spaces and control characters.
[Description]
WideTrim returns a copy of the supplied string with all leading and trailing spaces and
control characters removed. See <REF>UnicodeIsWhiteSpace</REF> and <REF>UnicodeIsControl</REF>
for what constitutes a space and control character respectively.
[Parameters]
Count=1
1=S:WideString=The string to trim.
[Result]
Copy of the supplied string without leading and trailing spaces and control characters.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=WideTrimLeft
2=WideTrimRight
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideTrimRight(const S: WideString): WideString;
[ShortDescr]
Trims trailing spaces and control characters.
[Description]
WideTrimRight returns a copy of the supplied string with all trailing spaces and
control characters removed. See <REF>UnicodeIsWhiteSpace</REF> and <REF>UnicodeIsControl</REF>
for what constitutes a space and control character respectively.
[Parameters]
Count=1
1=S:WideString=The string to trim.
[Result]
Copy of the supplied string without trailing spaces and control characters.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=WideTrimLeft
2=WideTrim
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideTrimLeft(const S: WideString): WideString;
[ShortDescr]
Trims leading spaces and control characters.
[Description]
WideTrimLeft returns a copy of the supplied string with all leading spaces and
control characters removed. See <REF>UnicodeIsWhiteSpace</REF> and <REF>UnicodeIsControl</REF>
for what constitutes a space and control character respectively.
[Parameters]
Count=1
1=S:WideString=The string to trim.
[Result]
Copy of the supplied string without leading spaces and control characters.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=WideTrim
2=WideTrimRight
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideLowerCase(C: WideChar): WideString; overload;
function WideLowerCase(const S: WideString): WideString; overload;
[ShortDescr]
Converts the supplied WideString or WideChar to lowercase.
[Description]
Converts the supplied WideString or WideChar to lowercase.
[Parameters]
Count=2
1=C:WideChar=The character to convert to lowercase.
2=S:WideString=The string to convert to lowercase.
[Result]
The lowercased string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideUpperCase(C: WideChar): WideString;
function WideUpperCase(const S: WideString): WideString;
[ShortDescr]
Converts the supplied WideString or WideChar to uppercase.
[Description]
Converts the supplied WideString or WideChar to uppercase.
[Parameters]
Count=2
1=C:WideChar=The character to convert to uppercase.
2=S:WideString=The string to convert to uppercase.
[Result]
The uppercased string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideTitleCaseString(C: WideChar): WideString;
function WideTitleCaseString(const S: WideString): WideString;
[ShortDescr]
Converts the supplied WideString or WideChar to titlecase.
[Description]
Converts the supplied WideString or WideChar to titlecase.
[Parameters]
Count=2
1=C:WideChar=The character to convert to titlecase.
2=S:WideString=The string to convert to titlecase.
[Result]
The titlecased string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideDecompose(const S: WideString; Compatible: Boolean): WideString;
[ShortDescr]
Performs a decomposition of all characters in the supplied string.
[Description]
Returns a copy of the string but with all individual characters decomposed into
their respective base characters. For example, the composite character  is
broken up into the two base characters E and ^.
[Parameters]
Count=2
1=S:WideString=The string for which to decompose the individual characters.
2=Compatible:Boolean=Flag to determine if compatibilty decomposition should be
used (True) or not (False).
[Result]
The decomposed string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideCompose(const S: WideString): WideString;
[ShortDescr]
Transforms a string into a composed string.
[Description]
Returns a string with all the characters of S, but if it is possible to combine
characters then they are composed.  For example, the two base characters E and ^
are combined into the composite character .
[Parameters]
Count=1
1=S:WideString=The string for which to compose the individual characters.
[Result]
The string with all characters composed, where possible.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideCharPos(const S: WideString; const Ch: WideChar; const Index: Integer): Integer;
[ShortDescr]
Returns the index of the first occurrence of Ch in S.
[Description]
WideCharPos returns the index of the first occurrence of the specified character
in the supplied string. Note that this is a search for the binary pattern, no attempt is made to
interpret either the given character or the string (ligatures, modifiers, surrogates etc.).
[Parameters]
Count=3
1=S:WideString=The string which to scan for the Ch character.
2=Ch:WideChar=The character to search for.
3=Index:Integer=The index at which to start searching in S. Usually you'll pass 1
to search the entire string (Note: the string is one based, not zero based!).
[Result]
Index of the first occurrence of the specified character in the supplied string.
This index is relative to the first character of the string, not relative to the
specified index.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideAdjustLineBreaks(const S: WideString): WideString;
[ShortDescr]
Standardizes linebreak characters to lineseparator characters.
[Description]
Standardizes linebreak characters to lineseparator characters by adjusting all
occurrences of CarriageReturn, LineFeed or a combination thereof into LineSeparators.
The function changes all occurrences of CarriageReturn and LineFeed into a
LineSeparator and turns the sequence LineFeed + CarriageReturn into two LineSeparators.
Only the CarriageReturn + LineFeed sequence is unaffected.
[Parameters]
Count=1
1=S:WideString=The string for which to adjust linebreaks.
[Result]
The linebreak adjusted string. This is a true copy of the string, the source string
is not affected.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrRNScanW(S1, S2: PWideChar): Integer;
[ShortDescr]
StrRNScan returns the length of the consecutive characters from the end of S1 which do not appear in S2.
[Description]
StrRNScanW is identical to StrNScanW with 2 small differences. The first one is
that the number of consecutive characters at the END of S1 is returned (not from
the start). Secondly, S1 is traversed in backward direction, so it should point
to the end of the actual string to be determined and there should a #0 character
at the beginning of S1 to terminate the loop. S2 is used as it is in StrNScanW
and points to the beginning of a sequence of characters. <BR>
This function is useful for buffers which contain a string in reversed order.
This is often the case for macro buffers which get the content of a string
a single character at a time, ending with #0 which is
then at the physical start of the string.
[Parameters]
Count=2
1=S1:PWideChar=Pointer to the end of the source string which must have have a #0
character at the start.
2=S2:PWideChar=The sequence (set) of characters to test against.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=StrNScan
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrNScanW(S1, S2: PWideChar): Integer;
[ShortDescr]
StrNScan returns the length of the consecutive characters in S1 which do not appear in S2.
[Description]
StrNScan returns the length of the consecutive characters in S1, from the start
of the string, which do not appear in S2. In other words: StrNScan returns the
length of the longest sequence in S1 for which the predicate "not (S1^ in S2)"
holds true if S2 were to be considered a set of characters. As an example consider
S1 to hold 'Project JEDI' and S2 to hold 'abcdef'. Calling StrNScan with these
parameters will return 4 since the fifth character, an 'e', appears in S2.
[Parameters]
Count=2
1=S1:PWideChar=The source string.
2=S2:PWideChar=The sequence (set) of characters to test against.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=StrRNScan
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure StrSwapByteOrder(Str: PWideChar);
[ShortDescr]
For each character in the string StrSwapByteOrder exchanges the low order and
high order byte to go from LSB to MSB and vice versa.
[Description]
For each character in the string StrSwapByteOrder exchanges the low order and
high order byte to go from LSB to MSB and vice versa.
[Parameters]
Count=1
1=Str:PWideChar=The string for which to swap the byte order of the individual
characters.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure StrDisposeW(Str: PWideChar);
[ShortDescr]
Release the memory of a wide character string.
[Description]
Release the memory of a wide character string previously allocated by <REF>StrNewW</REF>
or <REF>StrAllocW</REF>.
[Parameters]
Count=1
1=Str:PWideChar=The string to release.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrNewW(Str: PWideChar): PWideChar;
[ShortDescr]
Duplicates a wide character string.
[Description]
StrNewW makes a copy of the specified string, if not nil, and returns a pointer
to the duplicated string. The function makes an actual copy of the string not
just the pointer. When you are done using the string you must deallocate the memory
by using <REF>StrDisposeW</REF>. Do <U>not</U> simply pass it to FreeMem.
[Parameters]
Count=1
1=Str:PWideChar=The string to duplicate (copy).
[Result]
Pointer to the first character of the duplicated string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrAllocW(Size: Cardinal): PWideChar;
[ShortDescr]
Allocates a buffer for a null-terminated wide string.
[Description]
Allocates a buffer for a null-terminated wide string and returns a pointer to
the first character. The string is initially empty and initialized to all zeros.
When you are done using the string you must deallocate the memory by
using <REF>StrDisposeW</REF>. Do <U>not</U> simply pass it to FreeMem.
[Parameters]
Count=1
1=Size:Cardinal=Size of the string to allocate in terms of characters. This indicates
the total number of characters, including the null terminator. Thus, to allocate
a buffer to hold the string 'Project JEDI' you must use at least 13 as the Size
argument.
[Result]
Pointer to the first character of the allocated string.
[Notes]
Count=1
1=The function allocates SizeOf(Cardinal) more memory then you requested. This
additional Cardinal is stored at offset -4 of the returned pointer and is used to
hold the size of the buffer. You can use the <REF>StrBufSizeW</REF> function to
query for this value.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrBufSizeW(Str: PWideChar): Cardinal;
[ShortDescr]
Returns the buffer size for a null-terminated wide string.
[Description]
Returns the buffer size allocated for the specified null-terminated wide string.
[Parameters]
Count=1
1=Str:PWideChar=Null-terminated wide string
[Result]
Size of the buffer allocated for the null-terminated wide string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrPosW(Str, SubStr: PWideChar): PWideChar;
[ShortDescr]
[Description]
StrPosW returns a pointer to the first character of the first occurrence of SubStr
in Str. If SubStr does not occur in Str nil is returned.
[Parameters]
Count=2
1=Str:PWideChar=String to search for the first occurrence of SubStr.
2=SubStr:PWideChar=Substring to search for in Str.
[Result]
Pointer to the first character of the first occurrence of SubStr in Str or nil if
SubStr does not occur in Str.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=StrRScanW
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrRScanW(Str: PWideChar; Chr: WideChar): PWideChar;
[ShortDescr]
Scans the specified string for the occurrences of Chr.
[Description]
Scans the string for occurrences of the specified character and returns a pointer
to the last occurrence. The comparison between Str and Chr is case-sensitive.
[Parameters]
Count=2
1=Str:PWideChar=The string to scan for an occurrence of Chr.
2=Chr:WideChar=The character to scan for in Str.
[Result]
Pointer to the last occurrence of Chr in Str or nil if the character does not
occur in Str.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=StrPosW
2=StrScanW
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrScanW(Str: PWideChar; Chr: WideChar): PWideChar; overload;
function StrScanW(Str: PWideChar; Chr: WideChar; StrLen: Cardinal): PWideChar; overload;
[ShortDescr]
Scans the specified string for an occurrence of Chr.
[Description]
Scans at most StrLen characters in the specified string for an occurrence of Chr.
The comparison between Str and Chr is case-sensitive. Caller is responsible for
ensuring that StrLen never exceeds the length of the strings. The overloaded
routines without the StrLen parameter scans the string until it finds the character
or the end of the string. You should prefer the routine with the StrLen parameter
because it is much faster.
[Parameters]
Count=3
1=Str:PWideChar=The string to scan for an occurrence of Chr.
2=Chr:WideChar=The character to scan for in Str.
3=StrLen:Cardinal=Maximum number of characters to scan.
[Result]
Pointer to the first occurrence of Chr in Str or nil if the specified character
does not occur in Str.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=StrPosW
2=StrRScanW
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrLICompW(Str1, Str2: PWideChar; MaxLen: Cardinal): Integer;
[ShortDescr]
Case-insensitive, binary comparison of two null terminated strings.
[Description]
Case-insensitive, binary comparison of two null terminated strings.
[Parameters]
Count=2
1=Str1:PWideChar=First string
2=Str2:PWideChar=Second string
3=MaxLen:Cardinal=The maximum number of characters to compare.
[Result]
The return value should be interpreted as described in the table below. The actual
value indicates the ordinal difference between the first mismatching character in
the strings.
 <TABLE>
 <TR VALIGN="top">
 <TH align=left width =20%>Value</TH>
 <TH align=left width =80%>Description</TH>
 </TR>
 <TR VALIGN="top"><TD width=20%>&lt;0</TD><TD width=80%>Str1 &lt; Str2</TD>
 <TR VALIGN="top"><TD width=20%>0</TD><TD width=80%>Str1 equals Str2</TD>
 <TR VALIGN="top"><TD width=20%>&gt;0</TD><TD width=80%>Str1 &gt; Str2</TD>
 </TABLE>
[Notes]
Count=1
1=Only ANSI characters are compared case insensitively.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrLCompW(Str1, Str2: PWideChar; MaxLen: Cardinal): Integer;
[ShortDescr]
Case-sensitive, binary comparison of two null terminated strings.
[Description]
Case-sensitive, binary comparison of two null terminated strings.
[Parameters]
Count=3
1=Str1:PWideChar=First string
2=Str2:PWideChar=Second string
3=MaxLen:Cardinal=The maximum number of characters to compare.
[Result]
The return value should be interpreted as described in the table below. The actual
value indicates the ordinal difference between the first mismatching character in
the strings.
 <TABLE>
 <TR VALIGN="top">
 <TH align=left width =20%>Value</TH>
 <TH align=left width =80%>Description</TH>
 </TR>
 <TR VALIGN="top"><TD width=20%>&lt;0</TD><TD width=80%>Str1 &lt; Str2</TD>
 <TR VALIGN="top"><TD width=20%>0</TD><TD width=80%>Str1 equals Str2</TD>
 <TR VALIGN="top"><TD width=20%>&gt;0</TD><TD width=80%>Str1 &gt; Str2</TD>
 </TABLE>
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrICompW(Str1, Str2: PWideChar): Integer;
[ShortDescr]
Case-insensitive, binary comparison of two null terminated strings.
[Description]
Case-insensitive, binary comparison of two null terminated strings.
[Parameters]
Count=2
1=Str1:PWideChar=First string
2=Str2:PWideChar=Second string
[Result]
The return value should be interpreted as described in the table below. The actual
value indicates the ordinal difference between the first mismatching character in
the strings.
 <TABLE>
 <TR VALIGN="top">
 <TH align=left width =20%>Value</TH>
 <TH align=left width =80%>Description</TH>
 </TR>
 <TR VALIGN="top"><TD width=20%>&lt;0</TD><TD width=80%>Str1 &lt; Str2</TD>
 <TR VALIGN="top"><TD width=20%>0</TD><TD width=80%>Str1 equals Str2</TD>
 <TR VALIGN="top"><TD width=20%>&gt;0</TD><TD width=80%>Str1 &gt; Str2</TD>
 </TABLE>
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrCompW(Str1, Str2: PWideChar): Integer;
[ShortDescr]
Case-sensitive, binary comparison of two null terminated strings.
[Description]
Case-sensitive, binary comparison of two null terminated strings.
[Parameters]
Count=2
1=Str1:PWideChar=First string
2=Str2:PWideChar=Second string
[Result]
The return value should be interpreted as described in the table below. The actual
value indicates the ordinal difference between the first mismatching character in
the strings.
 <TABLE>
 <TR VALIGN="top">
 <TH align=left width =20%>Value</TH>
 <TH align=left width =80%>Description</TH>
 </TR>
 <TR VALIGN="top"><TD width=20%>&lt;0</TD><TD width=80%>Str1 &lt; Str2</TD>
 <TR VALIGN="top"><TD width=20%>0</TD><TD width=80%>Str1 equals Str2</TD>
 <TR VALIGN="top"><TD width=20%>&gt;0</TD><TD width=80%>Str1 &gt; Str2</TD>
 </TABLE>
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrLCatW(Dest, Source: PWideChar; MaxLen: Cardinal): PWideChar;
[ShortDescr]
Concatenates two strings enforcing a maximum for the total length.
[Description]
StrLCatW concatenates two strings and ensures that the resulting string is at
maximum MaxLen characters long. Thus, it appends at most MaxLen - StrLenW(Dest)
characters from Source to Dest.
[Parameters]
Count=3
1=Dest:PWideChar=Pointer to a string buffer to which to append characters from
Source. This buffer must have room to hold at least MaxLen + 1 characters.
2=Source:PWideChar=The string which is (partially) appended to Source.
3=MaxLen:Cardinal=Maximum length of the resulting string.
[Result]
Pointer to the destination string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=StrCatW
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrCatW(Dest, Source: PWideChar): PWideChar;
[ShortDescr]
Concatenates two strings.
[Description]
StrCatW appends Source to Dest and returns a pointer to the concatenated string.
The Dest buffer must have enough room to hold the concatenated string, no length
checking is performed. See <REF>StrLCatW</REF> for a length checking StrCatW.
[Parameters]
Count=2
1=Dest:PWideChar=Pointer to a string buffer to append Dest to.
2=Source:PWideChar=The string which is appended to Dest.
[Result]
Pointer to the Destination string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=StrLCatW
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrPLCopyW(Dest: PWideChar; const Source: String; MaxLen: Cardinal): PWideChar;
[ShortDescr]
Copies up to MaxLen characters from Source into Dest.
[Description]
Copies up to MaxLen characters from the Pascal style source string into a null
terminated wide string. The Dest buffer must have enough room to hold at least
MaxLen + 1 characters.
[Parameters]
Count=3
1=Dest:PWideChar=Pointer to a buffer which receives a (partial) copy of Source.
2=Source:string=Source string from which to copy up to MaxLen characters.
3=MaxLen:Cardinal=Maximum number of characters to copy from Source to Dest.
[Result]
Pointer to the destination string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=StrPCopyW
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrPCopyW(Dest: PWideChar; const Source: String): PWideChar;
[ShortDescr]
Copies a Pascal style string to a null terminated wide string.
[Description]
StrPCopyW copies a Pascal style string to a null terminated wide string. The Dest
buffer must have enough room to hold at least Length(Source) + 1 wide characters.
[Parameters]
Count=2
1=Dest:PWideChar=Pointer to a buffer which receives a copy of the source string.
2=Source:string=Source string to copy into Dest.
[Result]
Pointer to the destination string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=StrPLCopyW
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrLCopyW(Dest, Source: PWideChar; MaxLen: Cardinal): PWideChar;
[ShortDescr]
Copies MaxLen characters from Source to Dest.
[Description]
StrLCopyW copies up to MaxLen characters from Source to Dest and returns a
pointer to Dest. The Dest buffer must have enough room to hold at least MaxLen + 1
characters.
[Parameters]
Count=3
1=Dest:PWideChar=Buffer which receives a (partial) copy of Source
2=Source:PWideChar=Source string
3=MaxLen:Cardinal=Maximum number of characters to copy from Source to Dest.
[Result]
Pointer to the Destination string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrECopyW(Dest, Source: PWideChar): PWideChar;
[ShortDescr]
[Description]
StrECopyW copies the source string into the destination string and returns a
pointer to the null terminating character at the end of the destination string.
The function performs no length checking, the destination buffer must have room
for at least StrLenW(Source) + 1 characters.
[Parameters]
Count=2
1=Dest:PWideChar=Buffer which receives a copy of the source string.
2=Source:PWideChar=Source string to copy.
[Result]
Pointer to the null terminating character at the end of the destination string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=StrCopyW
2=StrMoveW
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrCopyW(Dest, Source: PWideChar): PWideChar;
[ShortDescr]
Copies the source string into the destination string.
[Description]
StrCopyW copies the source string into the destination string and returns a pointer
to the destination string. Dest must have been preallocated with enough room to
hold a copy of the source string (it must be at least StrLenW(Source) + 1
characters in length).
[Parameters]
Count=2
1=Dest:PWideChar=Pointer to a buffer that receives a copy of the source string.
The buffer have enough room to hold StrLenW(Source) + 1 characters.
2=Source:PWideChar=The string to copy.
[Result]
Pointer to the Dest string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=StrMoveW
2=StrECopyW
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrMoveW(Dest, Source: PWideChar; Count: Cardinal): PWideChar;
[ShortDescr]
Copies a string from Source to Dest.
[Description]
StrMoveW copies Count characters from Source to Destination. Dest must have
enough room to hold at least Count + 1 characters.
[Parameters]
Count=3
1=Dest:PWideChar=Pointer to a buffer that receives a copy of the source string.
2=Source:PWideChar=Source string from which to copy.
3=Count:Cardinal=The number of characters to copy from Source to Dest.
[Result]
Copy of the Dest pointer.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=StrCopyW
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrEndW(Str: PWideChar): PWideChar;
[ShortDescr]
Returns a pointer to the end of the string.
[Description]
StrEndW returns a pointer to the null terminating character at the end of the
specified string.
[Parameters]
Count=1
1=Str:PWideChar=Source string.
[Result]
Pointer to the end of the source string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function StrLenW(Str: PWideChar): Cardinal;
[ShortDescr]
Returns the length of the string in characters.
[Description]
StrLenW returns the length of the specified string, in characters, excluding the
null terminator.
[Parameters]
Count=1
1=Str:PWideChar=The string for which to determine the length
[Result]
The length of the specified string, in characters.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Null terminated strings
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function CharSetFromLocale(Language: LCID): TFontCharSet;
type TFontCharset = 0..255;
[ShortDescr]
Returns character set information for a given locale.
[Description]
The CharSetFromLocale function returns character set information for the specified
locale. The returned TFontCharSet record contains information such as the ANSI
code-page identifier. See the Platform SDK entries for CHARSETINFO and FONTSIGNATURE
for more information.
[Parameters]
Count=1
1=Language:LCID=The locale for which to retrieve character set information.
[Result]
A TFontCharSet record which describes the character set.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Utility functions
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=CodePageFromLocale
<DECL>--------------------------------------------------------------------------
[Declaration]
function CodePageFromLocale(Language: LCID): Integer;
[ShortDescr]
Returns the ANSI code page for a specific locale.
[Description]
CodePageFromLocale returns the ANSI code page associated with the specified locale.
If the locale does not use an ANSI code page, the system's current ANSI code page
is returned.
[Parameters]
Count=1
1=Langauge:LCID=Locale for which to retrieve the ANSI code page.
[Result]
The ANSI code page of the specified locale, or the system's current code page if
the locale does not use an ANSI code page.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Utility functions
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function CodeBlockFromChar(const C: UCS4): <REF Target"..\Types\TUnicodeBlock">TUnicodeBlock</REF>;
[ShortDescr]
Returns the character block (code block) for a character.
[Description]
The CodeBlockFromChar returns the code block (or character block) in which the
specified character exists. If the character does not belong to any defined block,
ubUndefined is returned.
[Parameters]
Count=1
1=C:WideChar=The unicode character for which you want to know the character block
in which it resides.
[Result]
The character block for the specified character. If the character does not belong to any defined block,
ubUndefined is returned.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Utility functions
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function KeyboardCodePage: Word;
[ShortDescr]
Returns the codepage based on the thread input locale.
[Description]
Returns the codepage for the calling thread based on the threads input locale
identifier (formerly called the keyboard layout). This effectively returns the
codepage associated with the keyboard and all other forms of input such as a
speech-to-text converter.
[Result]
Codepage for the calling thread, based on the keyboard layout.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Utility functions
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=CodePageFromLocale
<DECL>--------------------------------------------------------------------------
[Declaration]
function KeyUnicode(C: Char): WideChar;
[ShortDescr]
[Description]
Converts the specified character (as it comes with a WM_CHAR message) into its
corresponding Unicode character. The conversion is based upon the active keyboard
layout.
[Parameters]
Count=1
1=C:Char=The character to convert.
[Result]
The converted character.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Utility functions
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=KeyboardCodePage
<DECL>--------------------------------------------------------------------------
[Declaration]
function StringToWideStringEx(const S: String; CodePage: Word): WideString;
[ShortDescr]
Converts a string to a WideString.
[Description]
StringToWideStringEx maps a string to a Wide (unicode) string for the specified
codepage. This is merely a convenient wrapper for the MultiByteToWideChar API
function.
[Parameters]
Count=2
1=S:string=The string to convert to unicode
2=CodePage:Word=The code page to be used by the conversion. You can specify the
value of any available code page or one of the following values:
 <TABLE>
 <TR VALIGN="top"><TH align=left width=30%>Value</TH><TH align=left width=70%>Meaning</TH></TR>
 <TR VALIGN="top"><TD width=30%>CP_ACP</TD><TD width=70%>ANSI code page</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_MACCP</TD><TD width=70%>Macintosh code page</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_OEMCP</TD><TD width=70%>OEM code page</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_SYMBOL</TD><TD width=70%><B>Windows&nbsp;2000:</B> Symbol code page (42)</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_THREAD_ACP</TD><TD width=70%>The current thread's ANSI code page</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_UTF7</TD><TD width=70%><B>Windows NT 4.0 and Windows 2000:</B> Translate using UTF-7</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_UTF8</TD><TD width=70%><B>Windows NT 4.0 and Windows 2000:</B> Translate using UTF-8. When this is set, <I>dwFlags</I> must be zero.</TD></TR>
 </TABLE>
[Result]
The converted string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Utility functions
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=WideStringToStringEx
2=TranslateString
<DECL>--------------------------------------------------------------------------
[Declaration]
function TranslateString(const S: String; CP1, CP2: Word): String;
[ShortDescr]
Translates a string from one codepage to another.
[Description]
The TranslateString function translates the specified string from one codepage
to another.
[Parameters]
Count=3
1=S:string=The string to translate.
2=CP1:Word=Source code page.
2=CP2:Word=Destination code page.
[Result]
The translated string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Utility functions
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideStringToStringEx(const WS: WideString; CodePage: Word): String;
[ShortDescr]
WideStringToStringEx maps a WideString to a string based on the specified codepage.
[Description]
WideStringToStringEx maps a WideString to a string based on the specified codepage.
[Parameters]
Count=2
1=WS:WideString=The WideString to convert.
2=CodePage:Word=The code page to be used by the conversion. You can specify the
value of any available code page or one of the following values:
 <TABLE>
 <TR VALIGN="top"><TH align=left width=30%>Value</TH><TH align=left width=70%>Meaning</TH></TR>
 <TR VALIGN="top"><TD width=30%>CP_ACP</TD><TD width=70%>ANSI code page</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_MACCP</TD><TD width=70%>Macintosh code page</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_OEMCP</TD><TD width=70%>OEM code page</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_SYMBOL</TD><TD width=70%><B>Windows&nbsp;2000:</B> Symbol code page (42)</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_THREAD_ACP</TD><TD width=70%>The current thread's ANSI code page</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_UTF7</TD><TD width=70%><B>Windows NT 4.0 and Windows 2000:</B> Translate using UTF-7</TD></TR>
 <TR VALIGN="top"><TD width=30%>CP_UTF8</TD><TD width=70%><B>Windows NT 4.0 and Windows 2000:</B> Translate using UTF-8. When this is set, <I>dwFlags</I> must be zero.</TD></TR>
 </TABLE>
[Result]
The converted string.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Utility functions
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=StringToWideStringEx
2=TranslateString
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideStringToUTF8(S: WideString): AnsiString;
[ShortDescr]
Converts the given WideString to a UTF8 based AnsiString.
[Description]
Converts the given WideString to a UTF8 based AnsiString.
[Parameters]
Count=1
1=S:WideString=The unciode string to convert
[Result]
The string in UTF8 format.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString conversion routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=UTF8ToWideString
<DECL>--------------------------------------------------------------------------
[Declaration]
function UTF8ToWideString(S: AnsiString): WideString;
[ShortDescr]
Converts the given UTF8 based AnsiString to a WideString.
[Description]
Converts the given UTF8 based AnsiString to a WideString.
[Parameters]
Count=1
1=S:AnsiString=The UTF8 based AnsiString to convert to a WideString
[Result]
The string converted to a WideString.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString conversion routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=WideStringToUTF8
<DECL>--------------------------------------------------------------------------
[Declaration]
TSearchFlags = set of (sfCaseSensitive, sfIgnoreNonSpacing, sfSpaceCompress,
  sfWholeWordOnly);
[ShortDescr]
Flags used in the search class.
[Description]
Flags used in the search class.
[Enumeration]
Count=4
1=sfCaseSensitive=Match letter case
2=sfIgnoreNonSpacing=Ignore non-spacing characters in search
3=sfSpaceCompress=Handle several consecutive white spaces as one white space<BR>
                  (this applies to the pattern as well as the search text)
4=sfWholeWordOnly=Match only text at end/start and/or surrounded by white spaces
[Quick Info]
Kind=Type
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=TSearchEngine;..\TSearchEngine
<DECL>--------------------------------------------------------------------------
[Declaration]
TCharacterCategory = (ccLetterUppercase, ccLetterLowercase, ccLetterTitlecase,
  ccMarkNonSpacing, ccMarkSpacingCombining, ccMarkEnclosing, ccNumberDecimalDigit,
  ccNumberLetter, ccNumberOther, ccSeparatorSpace, ccSeparatorLine,
  ccSeparatorParagraph, ccOtherControl, ccOtherFormat, ccOtherSurrogate,
  ccOtherPrivate, ccOtherUnassigned, ccLetterModifier, ccLetterOther,
  ccPunctuationConnector, ccPunctuationDash, ccPunctuationOpen, ccPunctuationClose,
  ccPunctuationInitialQuote, ccPunctuationFinalQuote, ccPunctuationOther, ccSymbolMath,
  ccSymbolCurrency, ccSymbolModifier, ccSymbolOther, ccLeftToRight, ccLeftToRightEmbedding,
  ccLeftToRightOverride, ccRightToLeft, ccRightToLeftArabic, ccRightToLeftEmbedding,
  ccRightToLeftOverride, ccPopDirectionalFormat, ccEuropeanNumber, ccEuropeanNumberSeparator,
  ccEuropeanNumberTerminator, ccArabicNumber, ccCommonNumberSeparator, ccBoundaryNeutral,
  ccSegmentSeparator, ccWhiteSpace, ccOtherNeutrals, ccComposed, ccNonBreaking,
  ccSymmetric, ccHexDigit, ccQuotationMark, ccMirroring, ccSpaceOther, ccAssigned);
TCharacterCategories = set of TCharacterCategory;
[ShortDescr]
Various predefined or otherwise useful character property categories
[Description]
Various predefined or otherwise useful character property categories
[Enumeration]
Count=55
1=ccLetterUppercase=Uppercased letter
2=ccLetterLowercase=Lowercased letter
3=ccLetterTitlecase=Titlecased letter
4=ccMarkNonSpacing=Nonspacing mark
5=ccMarkSpacingCombining=Combining spacing mark
6=ccMarkEnclosing=Enclosing mark
7=ccNumberDecimalDigit=Decimal digit
8=ccNumberLetter=Letter representing a number
9=ccNumberOther=Other characters representing a number
10=ccSeparatorSpace=Space seperator
11=ccSeparatorLine=Line seperator
12=ccSeparatorParagraph=Paragraph seperator
13=ccOtherControl=Control character
14=ccOtherFormat=Format character
15=ccOtherSurrogate=Surrogate character
16=ccOtherPrivate=Private character
17=ccOtherUnassigned=Unassigned character
18=ccLetterModifier=Modifier character
19=ccLetterOther=Unclassified character
20=ccPunctuationConnector=Connecting punctuation character
21=ccPunctuationDash=Dash punctuation character
22=ccPunctuationOpen=Open punctuation character
23=ccPunctuationClose=Close punctuation character
24=ccPunctuationInitialQuote=Initial quote character
25=ccPunctuationFinalQuote=Final quote character
26=ccPunctuationOther=Undefined punctuation character
27=ccSymbolMath=Mathematical symbol
28=ccSymbolCurrency=Currency symbol
29=ccSymbolModifier=Modifier symbol
30=ccSymbolOther=Undefined symbol
31=ccLeftToRight=
32=ccLeftToRightEmbedding=
33=ccLeftToRightOverride=
34=ccRightToLeft=
35=ccRightToLeftArabic=
36=ccRightToLeftEmbedding=
37=ccRightToLeftOverride=
38=ccPopDirectionalFormat=
39=ccEuropeanNumber=
40=ccEuropeanNumberSeparator=
41=ccEuropeanNumberTerminator=
42=ccArabicNumber=
43=ccCommonNumberSeparator=
44=ccBoundaryNeutral=
45=ccSegmentSeparator=
46=ccWhiteSpace=
47=ccOtherNeutrals=
48=ccComposed=
49=ccNonBreaking=
50=ccSymmetric=Has left and right forms
51=ccHexDigit=Hexadecimal digit
52=ccQuotationMark=Quotation mark
53=ccMirroring=
54=ccSpaceOther=Undefined spacing character
55=ccAssigned=Defined character in Unicode-standard
[Notes]
Count=1
1=Categories ccComposed upto ccAssigned are self-defined categories and
do not appear in the Unicode data file. They are useful in the <REF TARGET"..\TURESearch\TURESearch">TURESearch-class</REF>.
[Quick Info]
Kind=Type
Unit=JclUnicode
Category=Unicode
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TSearchEngine = class (TObject)
[ShortDescr]
Abstract base class for the search engine.
[Description]
TSearchEngine is a generic search class defininition used for tuned Boyer-Moore
and Unicode regular expression searches.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
constructor Create(AOwner: TWideStrings); virtual;
[ShortDescr]
Instantiates a TSearchEngine object.
[Description]
Creates an instance of TSearchEngine and initializes the object for use. Since
TSearchEngine is an abstract base class you cannot actually instantiate it, instead
use a derived class such as TUTBMSearch or TURESearch. The TSearchEngine constructor only
initializes the results list and sets the Owner.
[Parameters]
Count=1
1=AOwner:TWideString=Owner of the search engine.
[Notes]
Count=1
1=The AOwner parameter, although assigned to the engine, is not used at all and can
therefore be <B>nil</B>. It's possible, however, that it will be used in the future.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
destructor Destroy; override;
[ShortDescr]
Destroys a TSearchEngine object.
[Description]
Destroys the search engine after clearing all results and freeing the results list.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetCount: Integer; virtual;
[ShortDescr]
Returns the number of matches.
[Description]
GetCount returns the number of matches and is used by the Count property.
[Result]
The number of matches found.
[Quick Info]
Kind=Method
Visibility=Protected
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure AddResult(Start, Stop: Cardinal); virtual;
[ShortDescr]
Adds a new match result.
[Description]
AddResult adds a new match result to the list.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Clear; virtual;
[ShortDescr]
Resets the search engine.
[Description]
Clear resets the search engine. TSearchEngine just calls ClearResult to clear the
match result list, but derivatives will also clear search patterns.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure ClearResults; virtual;
[ShortDescr]
Clear the match results.
[Description]
ClearResults clears the match result list.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure DeleteResult(Index: Cardinal); virtual;
[ShortDescr]
Removes a match from the result list.
[Description]
DeleteResult removes the specified match from the result list.
[Parameters]
Count=1
1=Index:Cardinal=Index of match to remove.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure FindPrepare(const Pattern: WideString; Options: <REF Target"..\Types\TSearchFlags">TSearchFlags</REF>); overload; virtual; abstract;
procedure FindPrepare(const Pattern: PWideChar; PatternLength: Cardinal; Options: <REF Target"..\Types\TSearchFlags">TSearchFlags</REF>); overload; virtual; abstract;
[ShortDescr]
Prepares the engine for a pattern search.
[Description]
FindPrepare prepares the engine for pattern search. There are 2 versions of
FindPrepare a WideString and a PWideChar version.
[Parameters]
Count=3
1=Pattern:Type=Search pattern
2=PatternLength:Cardinal=Length of pattern (available only in the PWideChar version)
3=Options:TSearchFlags=Search options. See <REF Target"..\Types\TSearchFlags">
TSearchFlags</REF> for more information on this parameter.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function FindFirst(const Text: WideString; var Start, Stop: Cardinal): Boolean; overload; virtual; abstract;
function FindFirst(const Text: PWideChar; TextLen: Cardinal; var Start, Stop: Cardinal): Boolean; overload; virtual; abstract;
[ShortDescr]
Finds the first occurence of a search pattern.
[Description]
FindFirst finds the first occurence of the pattern passed to <REF>FindPrepare</REF>
in Text and returns True if one could be found (in which case Start and Stop are
set to the according indices) otherwise False. This function is in particular of
interest if only one occurence needs to be found.
[Parameters]
Count=4
1=Text:Type=Text to be searched
2=TextLen:Cardinal=Length of text (available only in the PWideChar version)
3=Start:Cardinal=Start index of match if the function returned True, otherwise
undefined.
4=Stop:Cardinal=End index of match if the function returned True, otherwise
undefined.
[Result]
True is the pattern provided in FindPrepare was found in the Text parameter,
False otherwise.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=FindAll
<DECL>--------------------------------------------------------------------------
[Declaration]
function FindAll(const Text: WideString): Boolean; overload; virtual; abstract;
function FindAll(const Text: PWideChar; TextLen: Cardinal): Boolean; overload; virtual; abstract;
[ShortDescr]
Finds all occurences of a search pattern.
[Description]
FindAll finds all occurences of the pattern passed to <REF>FindPrepare</REF>
in Text and returns True if any could be found otherwise False.
[Parameters]
Count=2
1=Text:Type=Text to be searched
2=TextLen:Cardinal=Length of text (available only in the PWideChar version)
[Result]
True is the pattern provided in FindPrepare was found in the Text parameter,
False otherwise.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=FindFirst
2=GetResult
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure GetResult(Index: Cardinal; var Start, Stop: Integer); virtual;
[ShortDescr]
Returns a match result.
[Description]
GetResult returns the specified match result in the Start and Stop parameters.
[Parameters]
Count=3
1=Index:Cardinal=Index (0-based) of match result to return.
2=Start:Cardinal=Start position of match result.
3=Start:Cardinal=End position of match result.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=FindAll
2=Count;..\Properties\Count
<DECL>--------------------------------------------------------------------------
[Declaration]
property Count: Integer read GetCount;
[ShortDescr]
Indicates the number of matches found.
[Description]
Count determines the number of matches found after the last search
(with either <REF Target"..\Methods\FindFirst">FindFirst</REF>
or <REF Target"..\Methods\FindAll">FindAll</REF>).
[Quick Info]
Kind=Property
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TSearchEngine
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TUTBMSearch = class (<REF TARGET"..\TSearchEngine\TSearchEngine">TSearchEngine</REF>)
[ShortDescr]
Unicode Tuned Boyer-Moore Search class.
[Description]
TUTBMSearch is a Unicode Tuned Boyer-Moore (UTBM) search implementation. The class
handles low and high surrogates, case-(in)sensitivity, can ignore non-spacing
characters and optionally returns whole words only.
[Notes]
Count=1
1=This implementation is an extended translation from a free package written by
Mark Leisher (mleisher@crl.nmsu.edu).
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=TUTBMSearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure ClearPattern;
[ShortDescr]
Deletes the search pattern.
[Description]
ClearPattern deletes the current search pattern. Gets called by <REF>Clear</REF>.
[Quick Info]
Kind=Method
Visibility=Protected
Unit=JclUnicode
Category=Unicode
SubCat=TUTBMSearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Compile(Pattern: <REF TARGET"..\Types\PUCS2">PUCS2</REF>; PatternLength: Integer; Flags: <REF Target"..\..\TSearchEngine\Types\TSearchFlags">TSearchFlags</REF>);
[ShortDescr]
Compiles the pattern.
[Description]
Compile converts the pattern to an optimized internal structure. Compile gets
called by <REF>FindPrepare</REF>.
[Parameters]
Count=3
1=Pattern:PUSC2=Pattern to find
2=PatternLength:Integer=Length of pattern to find
3=Flags:TSearchFlags=Search options. See <REF Target"..\..\TSearchEngine\Types\TSearchFlags">TSearchFlags</REF>
for more information on this parameter.
[Quick Info]
Kind=Method
Visibility=Protected
Unit=JclUnicode
Category=Unicode
SubCat=TUTBMSearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function Find(Text: <REF TARGET"..\Types\PUCS2">PUCS2</REF>; TextLen: Cardinal; var MatchStart, MatchEnd: Cardinal): Boolean;
[ShortDescr]
Main matching routine using a tuned Boyer-Moore algorithm.
[Description]
Find is the main matching routine that implements a tuned Boyer-Moore algorithm.
Find gets called by <REF>FindFirst</REF> and <REF>FindAll</REF>.
[Parameters]
Count=4
1=Text:PUSC2=Text to search in.
2=TextLen:Cardinal=Length of text to search in.
3=MatchStart:Cardinal=Start of the match or undefined if no match.
4=MatchEnd:Cardinal=End of the match or undefined if no match.
[Result]
If the pattern can be found in Text the function returns True (in that case
MatchStart and MatchEnd point to the match) otherwise it returns False.
[Quick Info]
Kind=Method
Visibility=Protected
Unit=JclUnicode
Category=Unicode
SubCat=TUTBMSearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function Match(Text, Start, Stop: <REF TARGET"..\Types\PUCS2">PUCS2</REF>; var MatchStart, MatchEnd: Cardinal): Boolean;
[ShortDescr]
Checks wether the Text at Start matches the pattern.
[Description]
Match checks wether the text at Start matches the Pattern. It will also check the
borders if whole words are required.
[Parameters]
Count=5
1=Text:PUSC2=Complete Text to search in.
2=Start:PUSC2=First character to check.
3=Stop:PUSC2=Last character to check.
4=MatchStart:Cardinal=Start of the match or undefined if no match.
5=MatchEnd:Cardinal=End of the match or undefined if no match.
[Result]
If the Text at Start matches the pattern the function returns True (in that case
MatchStart and MatchEnd point to the match) otherwise it returns False.
[Notes]
Count=2
1=If whole words only are allowed then the left and right border tests are done
here too. The keypoint for the right border is that the next character after the
search string is either the text end or a space character. For the left side
this is similar, but there is nothing like a string start marker (like the
string end marker #0).</P><P>
2=It seems not obvious, but we still can use the passed Text pointer to do the
left check. Although this pointer might not point to the real string start (e.g.
in TUTBMSearch.FindAll Text is incremented as needed) it is still a valid check
mark. The reason is that Text either points to the real string start or a
previous match (happened already, keep in mind the search options do not change
in the FindAll loop) and the character just before Text is a space character.
This fact implies, though, that strings passed to Find (or FindFirst, FindAll in
TUTBMSearch) always really start at the given address. Although this might not
be the case in some circumstances (e.g. if you pass only the selection from an
editor) it is still assumed that a pattern matching from the first position on
(from the search string start) also matches when whole words only are allowed.
[Quick Info]
Kind=Method
Visibility=Protected
Unit=JclUnicode
Category=Unicode
SubCat=TUTBMSearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function GetSkipValue(TextStart, TextEnd: <REF TARGET"..\Types\PUCS2">PUCS2</REF>): Cardinal;
[ShortDescr]
Gets the skip value to use.
[Description]
GetSkipValue determines the skip value to use to advance to the next possible
match.
[Parameters]
Count=2
1=TextStart:PUSC2=Start of text to search
2=TextEnd:PUSC2=End of text to search
[Result]
Number of bytes to skip to restart matching. If this result is 0 (zero), we can
end the search algorithm.
[Quick Info]
Kind=Method
Visibility=Protected
Unit=JclUnicode
Category=Unicode
SubCat=TUTBMSearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure Clear; override;
[ShortDescr]
Resets the search engine.
[Description]
Clear resets the search engine by calling ClearPattern and then
calling the inherited Clear method.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TUTBMSearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure FindPrepare(const Pattern: WideString; Options: <REF Target"..\..\TSearchEngine\Types\TSearchFlags">TSearchFlags</REF>); overload; override; abstract;
procedure FindPrepare(const Pattern: PWideChar; PatternLength: Cardinal; Options: <REF Target"..\..\TSearchEngine\Types\TSearchFlags">TSearchFlags</REF>); overload; override; abstract;
[ShortDescr]
Prepares the engine for a pattern search.
[Description]
FindPrepare prepares the engine for pattern search. There are 2 versions of
FindPrepare a WideString and a PWideChar version.
[Parameters]
Count=3
1=Pattern:Type=Search pattern
2=PatternLength:Cardinal=Length of pattern (available only in the PWideChar version)
3=Options:TSearchFlags=Search options. See <REF Target"..\..\TSearchEngine\Types\TSearchFlags">
TSearchFlags</REF> for more information on this parameter.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TUTBMSearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function FindFirst(const Text: WideString; var Start, Stop: Cardinal): Boolean; overload; override; abstract;
function FindFirst(const Text: PWideChar; TextLen: Cardinal; var Start, Stop: Cardinal): Boolean; overload; override; abstract;
[ShortDescr]
Finds the first occurence of a search pattern.
[Description]
FindFirst finds the first occurence of the pattern passed to <REF>FindPrepare</REF>
in Text and returns True if one could be found (in which case Start and Stop are
set to the according indices) otherwise False. This function is in particular of
interest if only one occurence needs to be found.
[Parameters]
Count=4
1=Text:Type=Text to be searched
2=TextLen:Cardinal=Length of text (available only in the PWideChar version)
3=Start:Cardinal=Start index of match if the function returned True, otherwise
undefined.
4=Stop:Cardinal=End index of match if the function returned True, otherwise
undefined.
[Result]
True if the pattern provided in FindPrepare was found in the Text parameter,
False otherwise.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TUTBMSearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=FindAll
<DECL>--------------------------------------------------------------------------
[Declaration]
function FindAll(const Text: WideString): Boolean; overload; abstract;
function FindAll(const Text: PWideChar; TextLen: Cardinal): Boolean; overload; virtual; abstract;
[ShortDescr]
Finds all occurences of a search pattern.
[Description]
FindAll finds all occurences of the pattern passed to <REF>FindPrepare</REF>
in Text and returns True if any could be found otherwise False.
[Parameters]
Count=2
1=Text:Type=Text to be searched
2=TextLen:Cardinal=Length of text (available only in the PWideChar version)
[Result]
True is the pattern provided in FindPrepare was found in the Text parameter,
False otherwise.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TUTBMSearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=FindFirst
2=GetResult;..\..\TSearchEngine\Methods\GetResult
<DECL>--------------------------------------------------------------------------
[Declaration]
TURESearch = class (<REF TARGET"..\TSearchEngine\TSearchEngine">TSearchEngine</REF>)
[ShortDescr]
Unicode regular expression Search class.
[Description]
TURESearch is a Unicode Regular Expression (URE) search implementation. The class
handles low and high surrogates, case-(in)sensitivity, can ignore non-spacing
characters and optionally returns whole words only.</P><P>
  <B>Assumptions:</B><BR>
  <UL>
    <LI>Regular expression and text already normalized.</LI>
    <LI>Conversion to lower case assumes a 1-1 mapping.</LI>
  </UL>
  </P><P>
  <B>Definitions:</B><BR>
  <UL>
    <LI>Separator - any one of U+2028, U+2029, NL, CR.</LI>
  </UL>
  </P><P>
  <B>Operators:</B><BR>
  <TABLE>
  <TR VALIGN="top"><TH align=left width =20%>Operator</TH><TH align=left width =80%>Description</TH></TR>
  <TR VALIGN="top"><TD width=20%>.</TD><TD width=80%>match any character</TD></TR>
  <TR VALIGN="top"><TD width=20%>*</TD><TD width=80%>match zero or more of the last subexpression</TD></TR>
  <TR VALIGN="top"><TD width=20%>+</TD><TD width=80%>match one or more of the last subexpression</TD></TR>
  <TR VALIGN="top"><TD width=20%>?</TD><TD width=80%>match zero or one of the last subexpression</TD></TR>
  <TR VALIGN="top"><TD width=20%>()</TD><TD width=80%>subexpression grouping</TD></TR>
  <TR VALIGN="top"><TD width=20%>{m, n}</TD><TD width=80%>match at least m occurences and up to n occurences<BR>
                                                          <B>Note</B>: both values can be 0 (zero) or ommitted which denotes an unlimiting bound
                                                          {,} and {0,} and {0, 0} corresponds to *
                                                          {, 1} and {0, 1} corresponds to ?
                                                          {1,} and {1, 0} corresponds to +</TD></TR>
  <TR VALIGN="top"><TD width=20%>{m}</TD><TD width=80%>match exactly m occurences</TD></TR>
  </TABLE>
  </P><P>
  <B>Literals and Constants:</B><BR>
  <TABLE>
  <TR VALIGN="top"><TH align=left width =20%>Literal/Constant</TH><TH align=left width =80%>Description</TH></TR>
  <TR VALIGN="top"><TD width=20%>c</TD><TD width=80%>literal <REF TARGET"..\Types\PUCS2">UCS2</REF> character</TD></TR>
  <TR VALIGN="top"><TD width=20%>\x....</TD><TD width=80%>hexadecimal number of up to 4 digits</TD></TR>
  <TR VALIGN="top"><TD width=20%>\X....</TD><TD width=80%>hexadecimal number of up to 4 digits</TD></TR>
  <TR VALIGN="top"><TD width=20%>\u....</TD><TD width=80%>hexadecimal number of up to 4 digits</TD></TR>
  <TR VALIGN="top"><TD width=20%>\U....</TD><TD width=80%>hexadecimal number of up to 4 digits</TD></TR>
  </TABLE>
  </P><P>
  <B>Character classes:</B><BR>
  <UL>
    <LI>[...] denotes a character class.</LI>
    <LI>[^...] denotes a negated character class.</LI>
    <LI>Character classes can contain literals, POSIX classes and/or character property classes.</LI>
    <LI>POSIX classes are delimited by :<I>POSIX</I>:</LI>
    <LI>Character property classes are \p or \P (the latter denotes a negated property class)
        followed by a comma separated list of integers between 0 and the maximum entry index
        in <REF Target"..\Types\TCharacterCategory">TCharacterCategory</REF>. These integers
        directly correspond to the TCharacterCategory enumeration entries. <BR>
        <B>Note:</B> upper, lower and title case classes need to have case sensitive search
        enabled to match correctly!</LI>
  </UL>
[Notes]
Count=1
1=This implementation is an improved translation from the URE package written by
Mark Leisher (mleisher@crl.nmsu.edu) who used a variation of the RE->DFA
algorithm done by Mark Hopkins (markh@csd4.csd.uwm.edu).
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=TURESearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure FindPrepare(const Pattern: WideString; Options: <REF Target"..\..\TSearchEngine\Types\TSearchFlags">TSearchFlags</REF>); overload; override; abstract;
procedure FindPrepare(const Pattern: PWideChar; PatternLength: Cardinal; Options: <REF Target"..\..\TSearchEngine\Types\TSearchFlags">TSearchFlags</REF>); overload; override; abstract;
[ShortDescr]
Prepares the engine for a pattern search.
[Description]
FindPrepare prepares the engine for pattern search. There are 2 versions of
FindPrepare a WideString and a PWideChar version.
[Parameters]
Count=3
1=Pattern:Type=Search pattern
2=PatternLength:Cardinal=Length of pattern (available only in the PWideChar version)
3=Options:TSearchFlags=Search options. See <REF Target"..\..\TSearchEngine\Types\TSearchFlags">
TSearchFlags</REF> for more information on this parameter.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TURESearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function FindFirst(const Text: WideString; var Start, Stop: Cardinal): Boolean; overload; override; abstract;
function FindFirst(const Text: PWideChar; TextLen: Cardinal; var Start, Stop: Cardinal): Boolean; overload; override; abstract;
[ShortDescr]
Finds the first occurence of a search pattern.
[Description]
FindFirst finds the first occurence of the pattern passed to <REF>FindPrepare</REF>
in Text and returns True if one could be found (in which case Start and Stop are
set to the according indices) otherwise False. This function is in particular of
interest if only one occurence needs to be found.
[Parameters]
Count=4
1=Text:Type=Text to be searched
2=TextLen:Cardinal=Length of text (available only in the PWideChar version)
3=Start:Cardinal=Start index of match if the function returned True, otherwise
undefined.
4=Stop:Cardinal=End index of match if the function returned True, otherwise
undefined.
[Result]
True if the pattern provided in FindPrepare was found in the Text parameter,
False otherwise.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TURESearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=FindAll
<DECL>--------------------------------------------------------------------------
[Declaration]
function FindAll(const Text: WideString): Boolean; overload; abstract;
function FindAll(const Text: PWideChar; TextLen: Cardinal): Boolean; overload; virtual; abstract;
[ShortDescr]
Finds all occurences of a search pattern.
[Description]
FindAll finds all occurences of the pattern passed to <REF>FindPrepare</REF>
in Text and returns True if any could be found otherwise False.
[Parameters]
Count=2
1=Text:Type=Text to be searched
2=TextLen:Cardinal=Length of text (available only in the PWideChar version)
[Result]
True is the pattern provided in FindPrepare was found in the Text parameter,
False otherwise.
[Quick Info]
Kind=Method
Visibility=Public
Unit=JclUnicode
Category=Unicode
SubCat=TURESearch
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=2
1=FindFirst
2=GetResult;..\..\TSearchEngine\Methods\GetResult
<DECL>--------------------------------------------------------------------------
[Declaration]
PUTF7 = ^UTF7;
UTF7 = Char;
[ShortDescr]
Unicode transformation format data type UTF7
[Description]
Unicode transformation format data type UTF7
[Quick Info]
Kind=Type
Unit=JclUnicode
Category=Unicode
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
PUTF8 = ^UTF8;
UTF8 = Char;
[ShortDescr]
Unicode transformation format data type UTF8
[Description]
Unicode transformation format data type UTF8
[Quick Info]
Kind=Type
Unit=JclUnicode
Category=Unicode
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
PUTF16 = ^UTF16;
UTF16 = WideChar;
[ShortDescr]
Unicode transformation format data type UTF16
[Description]
Unicode transformation format data type UTF16
[Quick Info]
Kind=Type
Unit=JclUnicode
Category=Unicode
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
PUTF32 = ^UTF32;
UTF32 = Cardinal;
[ShortDescr]
Unicode transformation format data type UTF32
[Description]
Unicode transformation format data type UTF32
[Quick Info]
Kind=Type
Unit=JclUnicode
Category=Unicode
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
PUCS4 = ^UCS4;
UCS4 = Cardinal;
TUCS4Array = array of UCS4;
[ShortDescr]
UTF conversion scheme data type UCS4
[Description]
UTF conversion scheme data type UCS4
[Quick Info]
Kind=Type
Unit=JclUnicode
Category=Unicode
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
PUCS2 = PWideChar;
UCS2 = WideChar;
TUCS2Array = array of UCS2;
[ShortDescr]
UTF conversion scheme data type UCS2
[Description]
UTF conversion scheme data type UCS2
[Quick Info]
Kind=Type
Unit=JclUnicode
Category=Unicode
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TUcNumber = record
  Numerator: Integer;
  Denominator: Integer;
end;
[ShortDescr]
Record type for number-related Unicode functions.
[Description]
TUcNumber is a record used for number-related Unicode functions. '1/6' (U+2159)
would be converted to Numerator=1 and Denominator=6 by the <REF Target"..\Low level character routines\UnicodeNumberLookup">UnicodeNumberLookup</REF> function
[RecordFields]
Count=2
1=Numerator:Integer=Numerator of a number
2=Denominator:Integer=Denominator of a number
[Quick Info]
Kind=Type
Unit=JclUnicode
Category=Unicode
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=UnicodeNumberLookup;..\Low level character routines\UnicodeNumberLookup
<DECL>--------------------------------------------------------------------------
[Declaration]
  TNormalizationForm = (nfNone, nfC, nfD, nfKC, nfKD);
[ShortDescr]
Normalization form to use.
[Description]
Normalization form used in WideNormalize.
[Enumeration]
Count=5
1=nfNone=Do not normalize
2=nfC=canonical decomposition followed by canonical composition
3=nfD=canonical decomposition
4=nfKC=compatibility decomposition followed by a canonical composition
5=nfKD=compatibility decomposition
[Quick Info]
Kind=Type
Unit=JclUnicode
Category=Unicode
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
[SeeAlso]
Count=1
1=WideNormalize;..\WideString routines\WideNormalize
<DECL>--------------------------------------------------------------------------
[Declaration]
function WideNormalize(const S: WideString; Form: TNormalizationForm): WideString;
[ShortDescr]
Normalize a WideString.
[Description]
Returns a normalized string.
[Parameters]
Count=2
1=S:WideString=The string to normalize.
2=Form:TNormalizationForm=Type of normalization to use.
[Result]
The string normalized.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
procedure ExpandANSIString(const Source: PChar; Target: PWideChar; Count: Cardinal);
[ShortDescr]
Expands an ANSI string to a Widestring.
[Description]
Expands an ANSI string to a Widestring.
[Parameters]
Count=3
1=Source:PChar=Points to the ANSI string to be expanded
2=Target:PWideChar=Points to a WideString to receive the expanded string. Make 
sure that Target is large enough to hold the expanded ANSI string (ie. must be able
to hold at least 2*Count bytes).
3=Count:Cardinal=Number of characters to expand. 
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=WideString routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
function UnicodeComposePair(First, Second: <REF TARGET"..\Types\PUCS4">UCS4; var Composite: <REF TARGET"..\Types\PUCS4">UCS4): Boolean;
[ShortDescr]
Map two sequences into a composed codepoint.
[Description]
UnicodeComposePair maps the sequence of First and Second to a composed codepoint.
[Parameters]
Count=3
1=First:UCS4=The first sequence.
2=Second:USC4=The second sequence.
3=Composite:USC4=Composed version of the First and Second sequence.
[Result]
UnicodeComposePair returns True if there was a mapping (in which case Composite
is the composed version of First and Second) otherwise it returns False.
[Quick Info]
Unit=JclUnicode
Category=Unicode
SubCat=Low level character routines
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5
<DECL>--------------------------------------------------------------------------
[Declaration]
TUnicodeBlock = (ubUndefined, ubBasicLatin, ubLatin1Supplement,
  ubLatinExtendedA, ubLatinExtendedB, ubIPAExtensions, ubSpacingModifierLetters,
  ubCombiningDiacriticalMarks, ubGreek, ubCyrillic, ubArmenian, ubHebrew,
  ubArabic, ubSyriac, ubThaana, ubDevanagari, ubBengali, ubGurmukhi, ubGujarati,
  ubOriya, ubTamil, ubTelugu, ubKannada, ubMalayalam, ubSinhala, ubThai, ubLao,
  ubTibetan, ubMyanmar, ubGeorgian, ubHangulJamo, ubEthiopic, ubCherokee,
  ubUnifiedCanadianAboriginalSyllabics, ubOgham, ubRunic, ubKhmer, ubMongolian,
  ubLatinExtendedAdditional, ubGreekExtended, ubGeneralPunctuation,
  ubSuperscriptsAndSubscripts, ubCurrencySymbols, ubCombiningMarksForSymbols,
  ubLetterlikeSymbols, ubNumberForms, ubArrows, ubMathematicalOperators,
  ubMiscellaneousTechnical, ubControlPictures, ubOpticalCharacterRecognition,
  ubEnclosedAlphanumerics, ubBoxDrawing, ubBlockElements, ubGeometricShapes,
  ubMiscellaneousSymbols, ubDingbats, ubBraillePatterns,
  ubCJKRadicalsSupplement, ubKangxiRadicals, ubIdeographicDescriptionCharacters,
  ubCJKSymbolsAndPunctuation, ubHiragana, ubKatakana, ubBopomofo,
  ubHangulCompatibilityJamo, ubKanbun, ubBopomofoExtended,
  ubEnclosedCJKLettersAndMonths, ubCJKCompatibility,
  ubCJKUnifiedIdeographsExtensionA, ubCJKUnifiedIdeographs, ubYiSyllables,
  ubYiRadicals, ubHangulSyllables, ubHighSurrogates, ubHighPrivateUseSurrogates,
  ubLowSurrogates, ubPrivateUse, ubCJKCompatibilityIdeographs,
  ubAlphabeticPresentationForms, ubArabicPresentationFormsA,
  ubCombiningHalfMarks, ubCJKCompatibilityForms, ubSmallFormVariants,
  ubArabicPresentationFormsB, ubSpecials, ubHalfwidthAndFullwidthForms,
  ubOldItalic, ubGothic, ubDeseret, ubByzantineMusicalSymbols,
  ubMusicalSymbols, ubMathematicalAlphanumericSymbols,
  ubCJKUnifiedIdeographsExtensionB, ubCJKCompatibilityIdeographsSupplement,
  ubTags);
[ShortDescr]
Unicode block enumeration.
[Description]
An Unicode block usually corresponds to a particular language script but can
also represent special characters, musical symbols and the like.
[Enumeration]
Count=1
1=ubUndefined=Undefined block
[Quick Info]
Kind=Type
Unit=JclUnicode
Category=Unicode
Author=Mike Lischke;public@lischke-online.de
Delphi=4,5
BCB=4,5